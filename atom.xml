<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LH Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-12-06T08:14:37.863Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>香蕉BU娇</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL集群</title>
    <link href="http://example.com/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/"/>
    <id>http://example.com/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/</id>
    <published>2022-12-06T06:55:51.000Z</published>
    <updated>2022-12-06T08:14:37.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-集群"><a href="#MySQL-集群" class="headerlink" title="MySQL 集群"></a>MySQL 集群</h1><h1 id="mysql集群"><a href="#mysql集群" class="headerlink" title="mysql集群"></a>mysql集群</h1><ul><li>mysql的集群–高可用: 主从(搭建) 主主(搭建) 主从级联 主主级联</li><li>主从同步数据的原理: 异步复制 半同步复制</li><li>读写分离: 主(写) 从(读)</li><li>分片: 数据分开进行存储—&gt;水平 垂直(表 库)</li><li>分片的常用策略—mycat(练习+原理): id取模 hash取模 范围取模 枚举 一致性哈希(哈希环)—&gt;负载均衡策略</li></ul><h1 id="1-Mysql复制架构"><a href="#1-Mysql复制架构" class="headerlink" title="1 Mysql复制架构"></a>1 Mysql复制架构</h1><h2 id="1-1-数据拓展"><a href="#1-1-数据拓展" class="headerlink" title="1.1 数据拓展"></a>1.1 数据拓展</h2><ul><li>热备份：数据库在运行的过程中，对数据进行备份操作。相对的，还有冷备份，冷备份需要停机，然后对数据进行备份操作。</li><li>多活：所谓的多活，就是让数据库机器节点会存在多个，避免单点情况的出现。</li><li>故障切换：当一台数据库物理机出现异常状况时，可以自动的切换到其他物理机上。</li><li>读写分离：当存在存在多台数据库物理机，将读写操作分别交给不同的机器完成。</li><li>负载均衡：假设当存在多台数据库物理机接收读请求时，多个请求会均匀的分配到不同的机器上，避免大量请求压在某一台机器上。</li></ul><h2 id="1-2-常见架构"><a href="#1-2-常见架构" class="headerlink" title="1.2 常见架构"></a>1.2 常见架构</h2><p><strong>没有百分百的完美架构，只有适合的架构</strong></p><p>理解mysql的分库分表，先了解mysql的架构设计,在mysql架构中，经常会使用到的就是<br><strong>读写分离</strong>，此设计理念的基础上常见架构有: 一主一从或多从、主主复制、级联复制、主主与级联复制结合。<br><strong>一主一从或多从</strong>: 一个mysql数据库主节点,一个或者多个从节点.主节点与从节点进行数据同步<br><strong>主主复制</strong>: 两个mysql主节点,主节点与主节点之间进行数据同步<br><strong>主主与级联复制结合</strong>: 双主节点同步,同时从节点分级同步</p><p><strong>主主复制</strong>: 两个mysql主节点,主节点与主节点之间进行数据同步<strong>级联复制</strong>: 类似一主多从架构,但是从节点分级同步</p><h2 id="1-3-主从模式"><a href="#1-3-主从模式" class="headerlink" title="1.3 主从模式"></a>1.3 主从模式</h2><h3 id="1-3-1-主从简介"><a href="#1-3-1-主从简介" class="headerlink" title="1.3.1 主从简介"></a>1.3.1 主从简介</h3><p>主从模式是使用的最多的mysql高可用架构。<br>存在一台master作为写机，一个或多个slave作为读机,实现读写分离。之所以这么设计是因为在实际的情况下，读的请求量一般是远远大于写请求。架构图如下</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200524232046530.png"></p><p><strong>优点:</strong></p><p>读与写的节点分离,数据写入master节点后,再由master节点将数据复制到slave节点上</p><p><strong>缺点:</strong></p><ul><li>master是单点存在的，如果要对master进行停机维护，无法接收写请求</li><li>master需要将写入数据复制到各个slave节点，复制是有一定的时间延迟的，因此有可能出现查询数据不一致</li><li>对master进行停机维护，需将某一个slave提升为新的master节点，选举规则需要进行自定义</li><li>当slave被提升为新的master后，可能会造成新的master节点与旧master的数据不一致</li></ul><h3 id="1-3-2-主从搭建"><a href="#1-3-2-主从搭建" class="headerlink" title="1.3.2 主从搭建"></a>1.3.2 主从搭建</h3><p>在虚拟机中安装docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure><p>若遇到如下问题:</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607104243205.png" alt="image-20210607104243205"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#编辑yum的配置文件</span><br><span class="line">vi /etc/yum/pluginconf.d/langpacks.conf</span><br><span class="line">将第一行：enable=1改为enable=0</span><br><span class="line">#杀掉进程即可</span><br><span class="line">kill -9 8683</span><br></pre></td></tr></table></figure><p>查看docker版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br><span class="line">#开启启动docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">#查看运行状态</span><br><span class="line">systemctl status docker</span><br><span class="line">#启动</span><br><span class="line">systemctl start docker</span><br><span class="line">#停止</span><br><span class="line">systemctl stop docker</span><br><span class="line">#重启</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>搜索mysql镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p>下载mysql镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.io/mysql:5.7</span><br></pre></td></tr></table></figure><p>安装mysql容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#服务一</span><br><span class="line">docker run --name mysqlm1 -p 3306:3306 --privileged=true -ti -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -v /home/mysql/docker-data/m1/conf:/etc/mysql/conf.d -v /home/mysql/docker-data/m1/data/:/var/lib/mysql -v /home/mysql/docker-data/m1/logs/:/var/log/mysql -d mysql:5.7</span><br><span class="line">#服务二</span><br><span class="line">docker run --name mysqls1 -p 3306:3306 --privileged=true -ti -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -v /home/mysql/docker-data/s1/conf:/etc/mysql/conf.d -v /home/mysql/docker-data/s1/data/:/var/lib/mysql -v /home/mysql/docker-data/s1/logs/:/var/log/mysql -d mysql:5.7</span><br></pre></td></tr></table></figure><p>在两台机器上新增配置文件,路径为/home/mysql/docker-data/m1/conf/my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># For advice on how to change settings please see</span><br><span class="line"># http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">#</span><br><span class="line"># Remove leading # and set to the amount of RAM for the most important data</span><br><span class="line"># cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.</span><br><span class="line"># innodb_buffer_pool_size = 128M</span><br><span class="line">#</span><br><span class="line"># Remove leading # to turn on a very important data integrity option: logging</span><br><span class="line"># changes to the binary log between backups.</span><br><span class="line"># log_bin</span><br><span class="line">#</span><br><span class="line"># Remove leading # to set options mainly useful for reporting servers.</span><br><span class="line"># The server defaults are faster for transactions and fast SELECTs.</span><br><span class="line"># Adjust sizes as needed, experiment to find the optimal values.</span><br><span class="line"># join_buffer_size = 128M</span><br><span class="line"># sort_buffer_size = 2M</span><br><span class="line"># read_rnd_buffer_size = 2M</span><br><span class="line"></span><br><span class="line">character_set_server=utf8</span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line"></span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line">lower_case_table_names=1</span><br><span class="line">#指定主机号，不允许出现重复</span><br><span class="line">server-id=129</span><br><span class="line">#开启binlog</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">auto_increment_increment=2</span><br><span class="line">auto_increment_offset=1</span><br><span class="line"></span><br><span class="line">#rpl_semi_sync_master_enabled=1</span><br><span class="line">#rpl_semi_sync_master_timeout=10000</span><br></pre></td></tr></table></figure><p>vim /home/mysql/docker-data/s1/conf/my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># For advice on how to change settings please see</span><br><span class="line"># http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">#</span><br><span class="line"># Remove leading # and set to the amount of RAM for the most important data</span><br><span class="line"># cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.</span><br><span class="line"># innodb_buffer_pool_size = 128M</span><br><span class="line">#</span><br><span class="line"># Remove leading # to turn on a very important data integrity option: logging</span><br><span class="line"># changes to the binary log between backups.</span><br><span class="line"># log_bin</span><br><span class="line">#</span><br><span class="line"># Remove leading # to set options mainly useful for reporting servers.</span><br><span class="line"># The server defaults are faster for transactions and fast SELECTs.</span><br><span class="line"># Adjust sizes as needed, experiment to find the optimal values.</span><br><span class="line"># join_buffer_size = 128M</span><br><span class="line"># sort_buffer_size = 2M</span><br><span class="line"># read_rnd_buffer_size = 2M</span><br><span class="line"></span><br><span class="line">character_set_server=utf8</span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line"></span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line">lower_case_table_names=1</span><br><span class="line">#指定主机号，不允许出现重复</span><br><span class="line">server-id=130</span><br><span class="line">#开启binlog</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">auto_increment_increment=2</span><br><span class="line">auto_increment_offset=1</span><br><span class="line"></span><br><span class="line">#rpl_semi_sync_master_enabled=1</span><br><span class="line">#rpl_semi_sync_master_timeout=10000</span><br></pre></td></tr></table></figure><p>在master的docker容器中添加mysql权限，开启备份机复制，并且设置备份用户信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#在主服务中进入mysql容器</span><br><span class="line">docker exec -it mysqlm1 /bin/bash</span><br><span class="line">#root用户登录mysql</span><br><span class="line">mysql -uroot -p123456</span><br><span class="line">#添加权限</span><br><span class="line">GRANT REPLICATION SLAVE,FILE,REPLICATION CLIENT ON *.* TO &#x27;repluser&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">#刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">#重启容器</span><br><span class="line">docker restart mysqlm1</span><br><span class="line">#查看主服务的binlog信息</span><br><span class="line">show master status;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607110056280.png" alt="image-20210607110056280"></p><p>接着在slave中进入到mysql容器，设置master信息，用于标注当前slave的master是谁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#重启mysql容器</span><br><span class="line">docker restart mysqls1</span><br><span class="line">#进去docker容器</span><br><span class="line">docker <span class="keyword">exec</span> <span class="operator">-</span>it mysqls1 <span class="operator">/</span>bin<span class="operator">/</span>bash</span><br><span class="line">#登录root用户</span><br><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p123456</span><br><span class="line">#设置master信息</span><br><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;master的ip&#x27;</span>,master_port<span class="operator">=</span>master的端口号,master_user<span class="operator">=</span><span class="string">&#x27;repluser&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;master中的binlob文件&#x27;</span>,master_log_pos<span class="operator">=</span>master中的position位置信息;</span><br><span class="line"></span><br><span class="line">例：change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;192.168.2.128&#x27;</span>,master_port<span class="operator">=</span><span class="number">3306</span>,master_user<span class="operator">=</span><span class="string">&#x27;repluser&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;mysql-bin.000001&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">154</span>;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607110359218.png" alt="image-20210607110359218"></p><p>完成后，还需要开启slave中的<strong>IO</strong>和<strong>SQL</strong>线程，这两个线程主要用于slave中进行数据备份，可以先查看slave中这两个线程的状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> slave status\G;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607110453449.png" alt="image-20210607110453449"></p><p>我们发现在slave中，这两个线程是关闭的，需要将这两个线程进行开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#开启</span><br><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607110556762.png" alt="image-20210607110556762"></p><p>到此，mysql主从复制就已经搭建完毕</p><h3 id="1-3-3-测试"><a href="#1-3-3-测试" class="headerlink" title="1.3.3 测试"></a>1.3.3 测试</h3><p><strong>case1: 查看主从相关信息</strong></p><p>查看slave中的binlog是否已经开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;%log%&quot;;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607110722242.png" alt="image-20210607110722242"></p><p>查看master、slave中的进程信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">129</span>和<span class="number">130</span>分别输入</span><br><span class="line"><span class="keyword">show</span> processlist;</span><br></pre></td></tr></table></figure><p>129节点内容</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607110804268.png" alt="image-20210607110804268"></p><p>130节点内容</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607110842326.png" alt="image-20210607110842326"></p><p><strong>case2: 数据库同步测试</strong></p><p>在129节点创建一个数据库</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607111110116.png" alt="image-20210607111110116"></p><p>在130节点中查看数据库</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607111131335.png" alt="image-20210607111131335"></p><p><strong>case3: 表同步测试</strong></p><p>在129中创建一张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t_user`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user` (</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`password` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`address` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">10</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607111440773.png" alt="image-20210607111440773"></p><p>在130中查看表</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607111459565.png" alt="image-20210607111459565"></p><p><strong>case4: 数据同步</strong></p><p>在129中新增一条数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_user` <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607111612466.png" alt="image-20210607111612466"></p><p>在130中查看数据</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607111628561.png" alt="image-20210607111628561"></p><p><strong>case5: 反向数据同步</strong>(注意一定不要搞混!!!!!!)</p><p>在130中新增一条数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_user` <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607111741609.png" alt="image-20210607111741609"></p><p>在129中查看数据</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607111805185.png" alt="image-20210607111805185"></p><p><strong>结论: 从服务中新增数据无法同步到主服务中去, 主从同步是单向的!</strong></p><h2 id="1-4-主从复制原理"><a href="#1-4-主从复制原理" class="headerlink" title="1.4 主从复制原理"></a>1.4 主从复制原理</h2><h3 id="1-4-1-异步复制"><a href="#1-4-1-异步复制" class="headerlink" title="1.4.1 异步复制"></a>1.4.1 异步复制</h3><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200824144352020.png"></p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/Snipaste_2022-12-05_11-04-13-1670311488870.png"></p><ol><li>事务提交到master</li><li>master接收到应用事务提交请求后，更新内部的binlog日志，让mysql引擎执行事务操作，并返回给客户端执行结果信息。同时在master中会存在一个事件监听，其会一直监听着master中binlog日志文件的改变，一旦发现日志文件发生改变，触发dump线程</li><li>dump线程被触发后，通知slave中的IO线程现在有事务操作要进行同步</li><li>slave中IO线程接收到通知后，会从slave中<strong>relay-log.info</strong>文件中获取slave中的binlog日志文件和pos位置信息。接着会把这部分信息发送给master的dump线程</li><li>master的dump线程收到这些信息后，会根据slave发送的binlog日志文件和pos位置，将最新的binlog日志和pos位置后面的内容同步给slave的IO线程</li><li>slave的IO线程接收到这些信息后，会将这部分内容同步到slave中的relay-bin文件中</li><li>当relay-bin文件发生改变后，触发slave线程执行sql操作【异步】</li><li>当slave向relay-bin写入完成后，会向master返回一个ACK消息，同步成功。</li></ol><p>对于这一系列的操作，可以发现master和slave在进行同步时是以异步的方式完成的，master写入完binlog后，会马上通过引擎进行事务提交并向客户端返回响应，对于与slave同步的操作，则是异步完成的。</p><p><strong>优点:</strong>  效率高</p><p><strong>缺点:</strong>  可能出现数据不一致</p><h3 id="1-4-2-半同步复制"><a href="#1-4-2-半同步复制" class="headerlink" title="1.4.2 半同步复制"></a>1.4.2 半同步复制</h3><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200824144623639.png"></p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/Snipaste_2022-12-05_11-11-21-1670311519982.png"></p><p>半同步复制与异步复制的工作流程大体相似</p><p><strong>不同点:</strong> 当master中的binlog日志写入完成后，其不会马上通过引擎进行事务提交，而会处于等待，等到slave同步完成向master返回ACK通知后，才会唤醒等待，继续向下执行。</p><ul><li><p>等待的时长，默认为10秒，但该时间可以配置</p></li><li><p>尽量的避免了主从数据不一致，但造成吞吐量的降低</p></li><li><p>mysql兜底方案: 使用半同步复制进行备份时slave节点挂掉了，那么当master等待10秒后，仍然会进行引擎提交，同时会将半同步复制切换为异步复制。等到slave节点重启后，又会自动的从异步复制切换到半同步复制。</p></li></ul><h3 id="1-4-3-异步复制实现"><a href="#1-4-3-异步复制实现" class="headerlink" title="1.4.3 异步复制实现"></a>1.4.3 异步复制实现</h3><p>Mysql在进行复制操作时，默认是基于异步复制完成的。那为了更好的体会异步复制的效果，可以通过mysql日志来查看具体的复制过程效果。</p><ol><li><strong>查看master的Mysql日志信息</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f mysqlm1</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607113019936.png" alt="image-20210607113019936"></p><p>​    根据当前查看的日志信息，在master中已经开启了dump线程连接到了id为130的slave节点，并且该id就是在slave的mysql配置文件中设置的id。同时pos内容包括当前的binlog日志和pos位置。</p><ol start="2"><li><strong>查看slave的Mysql日志信息</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f mysqls1</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607113156502.png" alt="image-20210607113156502"></p><p>根据slave中的日志信息，可以看到，当前slave中已经开启了relay-log日志，其对应文件信息就是xxxxx-relay-bin。其内部保存的就是slave中的相关binlog信息和pos位置信息。<br>同时在slave中也已经开启了SQL Thread，并且根据信息可以，它会从7375d7dd3ef6-relay-bin.000001文件的4位置开始复制。<br>同时在slave中也开启了IO Thread，其已经连接到master，并且会从master的binlog日志的154的位置开启复制。</p><ol start="3"><li><strong>查看master当前的binlog日志信息</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd home/mysql/docker-data/129/data/</span><br><span class="line">#确定当前master正在使用的binlog日志文件</span><br><span class="line">cat mysql-bin.index</span><br><span class="line">#查看当前binlog日志文件内容</span><br><span class="line">tail -f mysql-bin.000001</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607113730796.png" alt="image-20210607113730796"></p><ol start="4"><li><strong>查看slave当前的日志信息</strong></li></ol><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607114023235.png" alt="image-20210607114023235"></p><h3 id="1-4-4-半同步复制实现"><a href="#1-4-4-半同步复制实现" class="headerlink" title="1.4.4 半同步复制实现"></a>1.4.4 半同步复制实现</h3><ol><li>进入mysql容器，加载lib，<strong>主从节点都要配置</strong>，因为主从节点间会存在切换。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">install plugin rpl_semi_sync_master soname <span class="string">&#x27;semisync_master.so&#x27;</span>;</span><br><span class="line">install plugin rpl_semi_sync_slave soname <span class="string">&#x27;semisync_slave.so&#x27;</span>;</span><br><span class="line">#查看插件信息</span><br><span class="line"><span class="keyword">show</span> plugins;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607114621298.png" alt="image-20210607114621298"></p><ol start="2"><li>启用半同步<strong>（务必先启用从库，再启用主库）</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#先启用从库，再启用主库</span><br><span class="line"></span><br><span class="line">从库：<span class="keyword">set</span> <span class="keyword">global</span> rpl_semi_sync_slave_enabled<span class="operator">=</span> <span class="number">1</span>;   # <span class="number">1</span>：启用，<span class="number">0</span>：禁止</span><br><span class="line"></span><br><span class="line">主库：</span><br><span class="line">     <span class="keyword">set</span> <span class="keyword">global</span> rpl_semi_sync_master_enabled<span class="operator">=</span> <span class="number">1</span>;   # <span class="number">1</span>：启用，<span class="number">0</span>：禁止</span><br><span class="line">     <span class="keyword">set</span> <span class="keyword">global</span> rpl_semi_sync_master_timeout<span class="operator">=</span><span class="number">10000</span>;   # 单位为ms</span><br></pre></td></tr></table></figure><ol start="3"><li>从库重启IO Thread</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop slave io_thread;</span><br><span class="line"><span class="keyword">start</span> slave io_thread;</span><br></pre></td></tr></table></figure><ol start="4"><li>查看启动状态</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询状态信息</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> &quot;%sync%&quot;;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607115008800.png" alt="image-20210607115008800"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询参数信息</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%sync%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607115025368.png" alt="image-20210607115025368"></p><ol start="5"><li>半同步复制效果测试</li></ol><ul><li>正常的向master中添加数据，slave可以进行正常数据更新</li></ul><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607115320148.png" alt="image-20210607115320148"></p><ul><li>关闭slave的IO,再次向master中添加数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop slave io_thread;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_user` <span class="keyword">VALUES</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;ding&#x27;</span>, <span class="string">&#x27;111&#x27;</span>, <span class="string">&#x27;武汉&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607115718465.png" alt="image-20210607115718465"></p><p><strong>此时复制机制会由半同步复制转换为异步复制，当再次向master中添加数据，不会再次出现等待</strong></p><ul><li>slave中重新开启IO Thread</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> slave io_thread;</span><br></pre></td></tr></table></figure><p>异步复制会再次转换为半同步复制，master中打印日志信息如下：</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607115905128.png" alt="image-20210607115905128"></p><p>在slave IO Tthread关闭这段时间内的数据，会同步到slave中，不会出现数据丢失</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607115930371.png" alt="image-20210607115930371"></p><h2 id="1-5-主主复制"><a href="#1-5-主主复制" class="headerlink" title="1.5 主主复制"></a>1.5 主主复制</h2><h3 id="1-5-1-简介"><a href="#1-5-1-简介" class="headerlink" title="1.5.1 简介"></a>1.5.1 简介</h3><p>对于主从复制来说，其内部会存在一台master以及一台或多台slave。但有一个非常明显的问题，<strong>master是单点存在</strong>。一旦master宕机，则无法进行数据的写入。为了解决这个问题，可以使用主主复制架构。</p><p>在主主复制架构中，会存在两台master，没有slave。并且会对这两台master进行读写分离，两台master会进行相互的复制, 架构图如下:</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200530012403644.png"></p><p>在此架构中，两台master会进行双向复制，为什么这么做呢？ 因为假设现在负责写的master宕机了，那么写的工作则会交给之前负责读的服务器来完成，相当于它即负责写又负责读。等到原先负责写的master恢复了，其在继续负责写工作。 反之亦然。因此才需要两者间进行双向复制。</p><p><strong>缺点: 读请求的并发量过大，服务可能产生宕机, 主主复制架构直接使用的情况较少。</strong></p><h3 id="1-5-2-主主搭建"><a href="#1-5-2-主主搭建" class="headerlink" title="1.5.2 主主搭建"></a>1.5.2 主主搭建</h3><p>在128和129服务器,再各自创建一个实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysqlm2 -p 3307:3306 --privileged=true -ti -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -v /home/mysql/docker-data/m2/conf:/etc/mysql/conf.d -v /home/mysql/docker-data/m2/data/:/var/lib/mysql -v /home/mysql/docker-data/m2/logs/:/var/log/mysql -d mysql:5.7</span><br></pre></td></tr></table></figure><p>vim /home/mysql/docker-data/m2/conf/my.cnf  (指定server-id)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># For advice on how to change settings please see</span><br><span class="line"># http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">#</span><br><span class="line"># Remove leading # and set to the amount of RAM for the most important data</span><br><span class="line"># cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.</span><br><span class="line"># innodb_buffer_pool_size = 128M</span><br><span class="line">#</span><br><span class="line"># Remove leading # to turn on a very important data integrity option: logging</span><br><span class="line"># changes to the binary log between backups.</span><br><span class="line"># log_bin</span><br><span class="line">#</span><br><span class="line"># Remove leading # to set options mainly useful for reporting servers.</span><br><span class="line"># The server defaults are faster for transactions and fast SELECTs.</span><br><span class="line"># Adjust sizes as needed, experiment to find the optimal values.</span><br><span class="line"># join_buffer_size = 128M</span><br><span class="line"># sort_buffer_size = 2M</span><br><span class="line"># read_rnd_buffer_size = 2M</span><br><span class="line"></span><br><span class="line">character_set_server=utf8</span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line"></span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line">lower_case_table_names=1</span><br><span class="line">#指定主机号，不允许出现重复</span><br><span class="line">server-id=139 </span><br><span class="line">#开启binlog</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">auto_increment_increment=2</span><br><span class="line">auto_increment_offset=1</span><br><span class="line"></span><br><span class="line">#rpl_semi_sync_master_enabled=1</span><br><span class="line">#rpl_semi_sync_master_timeout=10000</span><br></pre></td></tr></table></figure><p>添加slave的相关配置, 虽然是主主模式,也要添加从用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#添加权限</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE,FILE,REPLICATION CLIENT <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;repluser&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">#刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>主主搭建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#在<span class="number">129</span><span class="operator">/</span><span class="number">130</span>服务器上运行</span><br><span class="line"><span class="keyword">show</span> master status;</span><br><span class="line">#执行主主关联</span><br><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span>对方IP地址:<span class="string">&#x27;192.168.2.129&#x27;</span><span class="operator">/</span><span class="string">&#x27;192.168.2.128&#x27;</span>,master_port<span class="operator">=</span><span class="number">3307</span>,master_user<span class="operator">=</span><span class="string">&#x27;repluser&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;mysql-bin.000001&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">629</span>;</span><br><span class="line">#主主同步生效</span><br><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure><p>查看master 129的进程列表：show processlist;</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607143921793.png" alt="image-20210607143921793"></p><p>slave131的进程列表：show processlist;</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607143932355.png" alt="image-20210607143932355"></p><h2 id="1-6-级联复制-了解"><a href="#1-6-级联复制-了解" class="headerlink" title="1.6 级联复制(了解)"></a>1.6 级联复制(了解)</h2><p>写请求的入口为一个，但当master向slave进行复制时，对于slave可以分为多层， master只要向其中两台slave复制即可，然后再由slave将其数据复制到后面更多的slave中。通过这种方式可以减轻master向slave复制的IO压力。但是这种架构会使slave的延迟会加大,架构如下图:</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200601225751946.png"></p><h2 id="1-7-双主与级联复制-了解"><a href="#1-7-双主与级联复制-了解" class="headerlink" title="1.7 双主与级联复制(了解)"></a>1.7 双主与级联复制(了解)</h2><p>对于master在前面几种架构设计中，都存在单点问题， 对于master单点问题的解决，可以采用当前的架构。</p><p>通过这种架构不仅可以解决master单点的问题，也可以解决slave延迟的问题, 架构图如下:</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200601230908495.png"></p><h1 id="2-Mysql高可用-了解"><a href="#2-Mysql高可用-了解" class="headerlink" title="2 Mysql高可用(了解)"></a>2 Mysql高可用(了解)</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>以主主架构为例，现在不管写或者读，只要其中一个宕机，则会把它本身工作交给另外一台服务器完成。此时就需要对IP进行一个自动的指向。而且这种服务器IP切换，对于上层应用来说，应该是完全隐藏的，其无需知道当前是由谁来完成具体工作，其只需要来连接一个IP就可以。</p><p>对于这种需求，就需要通过<strong>keepAlived</strong>来完成IP的自动切换。</p><p> Keepalived是Linux下一个轻量级别的高可用解决方案。高可用(High Avalilability,HA)，其实两种不同的含义：广义来讲，是指整个系统的高可用行，狭义的来讲就是之主机的冗余和接管，</p><p>  它与HeartBeat RoseHA 实现相同类似的功能，都可以实现服务或者网络的高可用，但是又有差别，HeartBeat是一个专业的、功能完善的高可用软件，它提供了HA 软件所需的基本功能，比如：心跳检测、资源接管，检测集群中的服务，在集群节点转移共享IP地址的所有者等等。HeartBeat功能强大，但是部署和使用相对比较麻烦，</p><p>与HeartBeat相比，Keepalived主要是通过虚拟路由冗余来实现高可用功能，虽然它没有HeartBeat功能强大，但是Keepalived部署和使用非常的简单，所有配置只需要一个配置文件即可以完成</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200530020827979.png"></p><p>对于keepalived会在多台mysql服务器进行安装， 同时keepalived间也分为master和slave，  同时master会虚拟化一个VIP供应用进行连接。  如果一旦master挂掉后，会由slave节点继续工作，同时slave节点也会虚拟出相同VIP，供应用进行连接</p><h2 id="2-2-keepAlived安装与配置"><a href="#2-2-keepAlived安装与配置" class="headerlink" title="2.2 keepAlived安装与配置"></a>2.2 keepAlived安装与配置</h2><ol><li><strong>安装keepalived</strong></li></ol><p>下载keepalied安装包 <a href="http://www.keepalived.org/download.html">http://www.keepalived.org/download.html</a></p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607144828730.png" alt="image-20210607144828730"></p><p>安装相关的环境依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install killall</span><br><span class="line">yum -y install openssl-devel gcc gcc-c++</span><br></pre></td></tr></table></figure><p>yum install killall若出现以下错误,命令更换为yum install psmisc</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607145055820.png" alt="image-20210607145055820"></p><p>创建keepalived安装文件目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/keepalived</span><br></pre></td></tr></table></figure><p>上传文件并解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf keepalived-2.2.2.tar.gz</span><br></pre></td></tr></table></figure><p>将解压的程序复制到用户目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv keepalived-2.2.2 /usr/local/keepalived</span><br><span class="line">cd /usr/local/keepalived</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>创建启动文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp  -a /usr/local/etc/keepalived   /etc/init.d/</span><br><span class="line">cp  -a /usr/local/etc/sysconfig/keepalived    /etc/sysconfig/</span><br><span class="line">cp  -a /usr/local/sbin/keepalived    /usr/sbin/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写shell脚本,<strong>进入/etc/keepalived。创建chk.sh</strong>，同时赋予执行权限：chmod +x chk.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line">mysql -h 192.168.200.100 -u root -p123456 -P 3306 -e &quot;show status;&quot; &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">if [ $? == 0 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot; $host mysql login successfully &quot;</span><br><span class="line">    exit 0</span><br><span class="line">else</span><br><span class="line">    echo &quot;  mysql login faild&quot;</span><br><span class="line">    killall keepalived</span><br><span class="line">    exit 2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>编写keepalived配置文件keepalived.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_haproxy &#123;</span><br><span class="line">    script &quot;/etc/keepalived/chk.sh&quot;</span><br><span class="line">    interval 2  #脚本循环运行间隔</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.200.200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start keepalived</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep keepalived</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607154056173.png" alt="image-20210607154056173"></p><p>查看ip信息，此时可以发现出现了配置的虚拟ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607154142666.png" alt="image-20210607154142666"></p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210607154237635.png" alt="image-20210607154237635"></p><h1 id="3-数据分片"><a href="#3-数据分片" class="headerlink" title="3 数据分片"></a>3 数据分片</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>当前微服务架构非常流行，很多都会采用微服务架构对其系统进行拆分。 而虽然产生了多个微服务，但因为其用户量和数据量的问题，很有可能仍然使用的是同一个数据库。但是随着用户量和数据量增加，就会出现很多影响数据库性能的因素，如：数据存储量、IO瓶颈、访问量瓶颈等。此时就需要将数据进行拆分，从一个库拆分成多个库。</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200601232224434.png"></p><h2 id="3-2-水平切分"><a href="#3-2-水平切分" class="headerlink" title="3.2 水平切分"></a>3.2 水平切分</h2><p>为了解决垂直拆分出现的问题，可以使用水平拆分继续横向扩展，首先，可以如果<strong>当前数据库的容量没有问题</strong>的话，可以对读写极其频繁且数据量超大的表进行<strong>分表</strong>操作。由一张表拆分出多张表。</p><p>在一个库中，拆分出多张表，每张表存储不同的数据，这样对于其操作效率会有明显的提升。而且因为处于同一个库中，也不会出现分布式事务的问题。</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200602001628392.png"></p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/Snipaste_2022-12-05_11-47-50-1670311854784.png"></p><p>而拆分出多张表后，如果当前数据库的容量已经不够了，但是还要继续拆分的话，就可以进行<strong>分库</strong>操作，产生多个数据库，然后在扩展出的数据库中继续扩展表。</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200602002017703.png"></p><p><strong>水平分库可增加MySQL的访问连接数</strong></p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/Snipaste_2022-12-05_11-40-00-1670311893950.png"></p><p><strong>优点：</strong></p><ul><li>尽量的避免了跨库join操作</li><li>不会存在超大型表的性能瓶颈问题</li><li>事务处理相对简单</li><li>只要拆分规则定义好，很难出现扩展性的限制</li></ul><p><strong>缺点：</strong></p><ul><li>拆分规则不好明确，规则一定会和业务挂钩，如根据id、根据时间等</li><li>不好明确数据位置，难以进行维护</li><li>多数据源管理难度加大，代码复杂度增加</li><li>也会存在分布式事务问题</li><li>数据库维护成本增加</li></ul><h2 id="3-3-垂直切分"><a href="#3-3-垂直切分" class="headerlink" title="3.3 垂直切分"></a>3.3 垂直切分</h2><p>垂直拆分是按照业务将表进行分类并分布到不同的数据节点上。在初始进行数据拆分时，使用垂直拆分是非常直观的一种方式。</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200601235540364.png"></p><p><strong>根据业务不同将独立的数据独立在一个库中</strong></p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/Snipaste_2022-12-05_11-34-58-1670311995908.png"></p><p><strong>优点：</strong></p><ul><li>拆分规格明确，按照不同的功能模块或服务分配不同的数据库</li><li>数据维护与定位简单</li></ul><p><strong>缺点：</strong></p><ul><li>对于读写极其频繁且数据量超大的表，仍然存在存储与性能瓶颈。简单的索引此时已经无法解决问题</li><li>会出现跨库join</li><li>需要对代码进行重构，修改原有的事务操作</li><li>某个表数据量达到一定程度后扩展起来较为困难</li></ul><p><strong>水平分表</strong> ：但单体数据量过大时，字段太多，有关联字段，我们采用水平分表。</p><ul><li>减少个体数据体积，提交查询效率。</li><li>减少数据冗余。</li><li>频繁变化的（索引树的重构）</li></ul><h2 id="3-4-存在的问题"><a href="#3-4-存在的问题" class="headerlink" title="3.4 存在的问题"></a>3.4 存在的问题</h2><p><strong>数据切分带来的问题:</strong></p><ul><li>产生引入分布式事务的问题</li><li>跨节点 Join 的问题</li><li>跨节点合并排序分页问题</li></ul><p>例如: </p><ul><li>按照用户ID求模，将数据分散到不同的数据库，具有相同数据用户的数据都被分散到一个库中</li><li>按照日期，将不同月甚至日的数据分散到不同的库中</li><li>按照某个特定的字段求模，或者根据特定范围段分散到不同的库中</li></ul><h1 id="4-Mycat工具"><a href="#4-Mycat工具" class="headerlink" title="4 Mycat工具"></a>4 Mycat工具</h1><h2 id="4-1-Mycat简介"><a href="#4-1-Mycat简介" class="headerlink" title="4.1 Mycat简介"></a>4.1 Mycat简介</h2><p>当对数据拆分后会产生诸多的问题，对于这些问题的解决，可以借助于数据库中间件来进行解决，现在时下比较流行的是使用Mycat。</p><p>Mycat是一款数据库中间件，对于应用程序来说是完全透明化的，不管底层的数据如何拆分，应用只需要连接Mycat即可完成对数据的操作。同时它还支持MySQL、SQL Server、Oracle、DB2、PostgreSQL等主流数据库。但是Mycat不会进行数据存储，它只是用于数据的路由。</p><p>其底层是基于拦截思想实现，其会拦截用户发送过来的SQL语句，首先对SQL语句做了一些特定的分析：如分片分析、路由分析、读写分离分析、缓存分析等，然后将此SQL发往后端的真实数据库，并将返回的结果做适当的处理，最终再返回给用户。</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200602235241816.png"></p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/Snipaste_2022-12-05_13-56-48-1670314227209.png"></p><p>Mycat的特性如下:</p><ul><li>支持SQL92标准</li><li>遵守Mysql原生协议，跨语言，跨平台，跨数据库的通用中间件代理</li><li>基于心跳的自动故障切换，支持读写分离，支持MySQL主从，以及galera cluster集群</li><li>支持Galera for MySQL集群，Percona Cluster或者MariaDB cluster</li><li>基于Nio实现，有效管理线程，高并发问题</li><li>支持数据的多片自动路由与聚合，支持sum,count,max等常用的聚合函数</li><li>支持单库内部任意join，支持跨库2表join</li><li>支持通过全局表，ER关系的分片策略，实现了高效的多表join查询</li><li>支持多租户方案</li><li>支持分布式事务</li><li>支持全局序列号，解决分布式下的主键生成问题</li><li>分片规则丰富，插件化开发，易于扩展</li><li>强大的web，命令行监控</li><li>支持前端作为mysq通用代理，后端JDBC方式支持Oracle、DB2、SQL Server 、 mongodb </li><li>支持密码加密</li><li>支持服务降级</li><li>支持IP白名单</li><li>支持SQL黑名单、sql注入攻击拦截</li><li>支持分表(1.6以后版本)</li><li>集群基于ZooKeeper管理，在线升级，扩容，智能优化，大数据处理（2.0以后版本）</li></ul><h2 id="4-2-Mycat安装"><a href="#4-2-Mycat安装" class="headerlink" title="4.2 Mycat安装"></a>4.2 Mycat安装</h2><p><strong>源码下载：</strong><a href="https://codeload.github.com/MyCATApache/Mycat-Server/zip/Mycat-server-1675-release">https://codeload.github.com/MyCATApache/Mycat-Server/zip/Mycat-server-1675-release</a></p><p><strong>官网:</strong> <a href="http://www.mycat.org.cn/">http://www.mycat.org.cn/</a></p><p><strong>默认端口：8066</strong></p><p><strong>配置启动参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#环境变量</span><br><span class="line">-DMYCAT_HOME=D:\workspace\Mycat-Server-Mycat-server-1675-release\src\main</span><br><span class="line">#设置堆外内存大小:当使用mycat对非分片查询时，会把所有的数据查询出来，然后把这部分数据放在堆外内存中</span><br><span class="line">-XX:MaxDirectMemorySize=512M </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Mycat有核心三个配置文件，分别为：<strong>sever.xml、schema.xml、rule.xml</strong></p><ul><li><strong>sever.xml</strong>：是Mycat服务器参数调整和用户授权的配置文件</li><li><strong>schema.xml</strong>：是逻辑库定义和表以及分片定义的配置文件</li><li><strong>rule.xml</strong>：是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件，也在这个目录下，配置文件修改需要重启</li></ul><h2 id="4-3-Mycat核心概念"><a href="#4-3-Mycat核心概念" class="headerlink" title="4.3 Mycat核心概念"></a>4.3 Mycat核心概念</h2><ul><li><strong>逻辑库</strong>：Mycat中的虚拟数据库。对应实际数据库的概念。在没有使用mycat时，应用需要确定当前连接的数据库等信息，那么当使用mycat后，也需要先虚拟一个数据库，用于应用的连接。</li><li><strong>逻辑表</strong>：mycat中的虚拟数据表。对应时间数据库中数据表的概念。</li><li><strong>非分片表</strong>：没有进行数据切分的表。</li><li><strong>分片表</strong>：已经被数据拆分的表，每个分片表中都有原有数据表的一部分数据。多张分片表可以构成一个完整数据表。</li><li><strong>ER表</strong>：子表的记录与所关联的父表记录存放在同一个数据分片上，即子表依赖于父表，通过表分组（Table Group）保证数据Join不会跨库操作。表分组（Table Group）是解决跨分片数据join的一种很好的思路，也是数据切分规划的重要一条规则</li><li><strong>全局表</strong>：可以理解为是一张数据冗余表，如状态表，每一个数据分片节点又保存了一份状态表数据。数据冗余是解决跨分片数据join的一种很好的思路，也是数据切分规划的另外一条重要规则。</li><li><strong>分片节点（dataNode）</strong>：数据切分后，每一个数据分片表所在的数据库就是分片节点。</li><li><strong>节点主机（dataHost）</strong>：数据切分后，每个分片节点（dataNode）不一定都会独占一台机器，同一机器上面可以有多个分片数据库，这样一个或多个分片节点（dataNode）所在的机器就是节点主机（dataHost）,为了规避单节点主机并发数限制，尽量将读写压力高的分片节点（dataNode）均衡的放在不同的节点主机（dataHost）。</li><li><strong>分片规则（rule）</strong>：按照某种业务规则把数据分到某个分片的规则就是分片规则。</li><li><strong>全局序列号（sequence）</strong>：也可以理解为分布式id。数据切分后，原有的关系数据库中的主键约束在分布式条件下将无法使用，因此需要引入外部机制保证数据唯一性标识，这种保证全局性的数据唯一标识的机制就是全局序列号（sequence），如UUID、雪花算法等。</li></ul><h1 id="5-Mycat入门"><a href="#5-Mycat入门" class="headerlink" title="5 Mycat入门"></a>5 Mycat入门</h1><h2 id="5-1-环境准备"><a href="#5-1-环境准备" class="headerlink" title="5.1 环境准备"></a>5.1 环境准备</h2><p>在server.xml 文件中的system标签下配置所有的参数，全部为环境参数，可以根据当前需要进行开启和配置，如：设置mycat连接端口号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serverPort&quot;</span>&gt;</span>8066<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200603010530819.png"></p><h2 id="5-2-通过Mycat访问数据库"><a href="#5-2-通过Mycat访问数据库" class="headerlink" title="5.2 通过Mycat访问数据库"></a>5.2 通过Mycat访问数据库</h2><h3 id="5-2-1-server-xml配置"><a href="#5-2-1-server-xml配置" class="headerlink" title="5.2.1 server.xml配置"></a>5.2.1 server.xml配置</h3><p>应用连接mycat的话，也需要设置用户名、密码、被连接数据库信息，要配置这些信息的话，可以修改server.xml，在其内部添加内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置自定义用户信息--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--连接用户名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;mycat&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接密码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>mycat<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--创建虚拟数据库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>userDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定该库是否只读--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;readOnly&quot;&gt;true&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-2-schema-xml配置"><a href="#5-2-2-schema-xml配置" class="headerlink" title="5.2.2 schema.xml配置"></a>5.2.2 schema.xml配置</h3><p>当配置了一个虚拟数据库后，还需要修改schema.xml，对虚拟库进行详细配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置虚拟数据库--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name：虚拟逻辑数据库名称，对应server.xml中的schemas属性值--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--dataNode：逻辑库中逻辑表的默认数据节点--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--sqlMaxLimit：类似于SQL上添加limit，如schema为非分片库，则该属性无效--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;userDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;localdn&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置虚拟逻辑表--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name：逻辑表名称，必须唯一--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--dataNode：逻辑表所处的数据节点，值必须与dataNode标签中的name属性对应。如果值过多可以用$连接，如：dn$1-99,dn$200-400--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--primaryKey：逻辑表对应的真实表的主键id的字段名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;localdn&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置dataNode信息--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name：当前datanode名称--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--dataHost：分片节点所处的节点主机，该值必须与dataHost标签中的name属性对应--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--database：当前数据节点所对应的实际物理数据库--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;localdn&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localdh&quot;</span> <span class="attr">database</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置节点主机--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--balance：用于进行读操作指向，有三个值可选</span></span><br><span class="line"><span class="comment">0：所有读操作都发送到当前可用的writeHost上</span></span><br><span class="line"><span class="comment">1：所有读操作都随机的发送到readHost上</span></span><br><span class="line"><span class="comment">2：所有读操作都随机发送在writeHost与readHost上</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--maxCon：指定每个读写实例连接池的最大连接。也就是说，标签内嵌套的writeHost、readHost标签都会使用这个属性的值来实例化出连接池的最大连接数--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--minCon：指定每个读写实例连接池的最小连接，初始化连接池的大小--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name：当前节点主机名称，不允许出现重复--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--dbType：当时使用的数据库类型--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--dbDriver：当前使用的数据库驱动--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--writeType：用于写操作指向，有三个值可选</span></span><br><span class="line"><span class="comment">0：所有写操作都发送到可用的writeHost上</span></span><br><span class="line"><span class="comment">1：所有写操作都随机发送到readHost上</span></span><br><span class="line"><span class="comment">2：所有写操作都随机发送在writeHost与readHost上</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--readHost是从属于writeHost的，即意味着它从那个writeHost获取同步数据。</span></span><br><span class="line"><span class="comment">因此，当它所属的writeHost宕机了，则它也不会再参与到读写分离中来，即“不工作了”。这是因为此时，它的数据已经“不可靠”了。</span></span><br><span class="line"><span class="comment">基于这个考虑，目前mycat 1.3和1.4版本中，若想支持MySQL一主一从的标准配置，并且在主节点宕机的情况下，从节点还能读取数据。</span></span><br><span class="line"><span class="comment">则需要在Mycat里配置为两个writeHost并设置banlance=1。”--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--switchType：设置节点切换操作，有三个值可选</span></span><br><span class="line"><span class="comment">-1：不自动切换</span></span><br><span class="line"><span class="comment">1：自动切换，默认值</span></span><br><span class="line"><span class="comment">2：基于mysql主从同步的状态决定是否切换</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--slaveThreshold：主从同步状态决定是否切换，延迟超过该值就不切换--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;100&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">name</span>=<span class="string">&quot;localdh&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--查询心跳--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置写节点实际物理数据库信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://localhost:3306&quot;</span> <span class="attr">host</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-2-3-访问测试"><a href="#5-2-3-访问测试" class="headerlink" title="5.2.3 访问测试"></a>5.2.3 访问测试</h3><p>通过navicat创建本地数据库连接并创建对应数据库，同时创建mycat连接。 在mycat连接中操作表，添加数据，可以发现，本地数据库中同步的也新增了对应的数据。</p><h2 id="5-3-数据分片"><a href="#5-3-数据分片" class="headerlink" title="5.3 数据分片"></a>5.3 数据分片</h2><h3 id="5-3-1-取模分片"><a href="#5-3-1-取模分片" class="headerlink" title="5.3.1 取模分片"></a>5.3.1 取模分片</h3><p>当一个数据表中的数据量非常大时，就需要考虑对表内数据进行分片，拆分的规则有很多种，比较简单的一种就是，通过对id进行取模，完成数据分片。</p><ol><li><strong>修改schema.xml</strong></li></ol><p>table标签新增属性：subTables、rule</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置虚拟数据库--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name：虚拟逻辑数据库名称，对应server.xml中的schemas属性值--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--dataNode：逻辑库中逻辑表的默认数据节点--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--sqlMaxLimit：类似于SQL上添加limit，如schema为非分片库，则该属性无效--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;userDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;localdn&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置虚拟逻辑表--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name：逻辑表名称，必须唯一--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--dataNode：逻辑表所处的数据节点，值必须与dataNode标签中的name属性对应。如果值过多可以用$连接，如：dn$1-99,dn$200-400--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--primaryKey：逻辑表对应的真实表的主键id的字段名--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--subTables：分表的名称。可以存在多个，tb_user1,tb_user2,tb_user3.如果分表较多，可以通过$连接：tb_user$1-3--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--rule：分片规则，对应rule.xml中配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;localdn&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">subTables</span>=<span class="string">&quot;tb_user$1-3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置dataNode信息--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name：当前datanode名称--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--dataHost：分片节点所处的节点主机，该值必须与dataHost标签中的name属性对应--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--database：当前数据节点所对应的实际物理数据库--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;localdn&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localdh&quot;</span> <span class="attr">database</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置节点主机--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--balance：用于进行读操作指向，有三个值可选</span></span><br><span class="line"><span class="comment">0：所有读操作都发送到当前可用的writeHost上</span></span><br><span class="line"><span class="comment">1：所有读操作都随机的发送到readHost上</span></span><br><span class="line"><span class="comment">2：所有读操作都随机发送在writeHost与readHost上</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--maxCon：指定每个读写实例连接池的最大连接。也就是说，标签内嵌套的writeHost、readHost标签都会使用这个属性的值来实例化出连接池的最大连接数--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--minCon：指定每个读写实例连接池的最小连接，初始化连接池的大小--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name：当前节点主机名称，不允许出现重复--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--dbType：当时使用的数据库类型--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--dbDriver：当前使用的数据库驱动--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--writeType：用于写操作指向，有三个值可选</span></span><br><span class="line"><span class="comment">0：所有写操作都发送到可用的writeHost上</span></span><br><span class="line"><span class="comment">1：所有写操作都随机发送到readHost上</span></span><br><span class="line"><span class="comment">2：所有写操作都随机发送在writeHost与readHost上</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--readHost是从属于writeHost的，即意味着它从那个writeHost获取同步数据。</span></span><br><span class="line"><span class="comment">因此，当它所属的writeHost宕机了，则它也不会再参与到读写分离中来，即“不工作了”。这是因为此时，它的数据已经“不可靠”了。</span></span><br><span class="line"><span class="comment">基于这个考虑，目前mycat 1.3和1.4版本中，若想支持MySQL一主一从的标准配置，并且在主节点宕机的情况下，从节点还能读取数据。</span></span><br><span class="line"><span class="comment">则需要在Mycat里配置为两个writeHost并设置banlance=1。”--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--switchType：设置节点切换操作，有三个值可选</span></span><br><span class="line"><span class="comment">-1：不自动切换</span></span><br><span class="line"><span class="comment">1：自动切换，默认值</span></span><br><span class="line"><span class="comment">2：基于mysql主从同步的状态决定是否切换</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--slaveThreshold：主从同步状态决定是否切换，延迟超过该值就不切换--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;100&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">name</span>=<span class="string">&quot;localdh&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--查询心跳--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置写节点实际物理数据库信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://localhost:3306&quot;</span> <span class="attr">host</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>修改rule.xml</strong></li></ol><p>​    在schema.xml中已经指定规则为mod-long。因此需要到该文件中修改对应信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当用用于id取模的字段--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>user_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--修改当前的分片数量--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根据datanode数量进行取模分片，也就是要模几。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>新增数据</strong></li></ol><ul><li><p>向数据库中插入9条数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test(id) <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test(id) <span class="keyword">VALUES</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test(id) <span class="keyword">VALUES</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test(id) <span class="keyword">VALUES</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test(id) <span class="keyword">VALUES</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test(id) <span class="keyword">VALUES</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test(id) <span class="keyword">VALUES</span>(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test(id) <span class="keyword">VALUES</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test(id) <span class="keyword">VALUES</span>(<span class="number">9</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过id查询数据</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210608092140619.png" alt="image-20210608092140619"></p></li><li><p>查询所有数据</p></li></ul><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20210608092208288.png" alt="image-20210608092208288"></p><ol start="4"><li><strong>问题分析</strong></li></ol><ul><li>散列不均匀，出现数据倾斜<ul><li>每张表中的数据量差距较大</li></ul></li><li>动态扩容时，存在rehash，出现数据丢失<ul><li>动态扩容后新增表时，需要对模数修改时有可能就会造成当查询某个分片时，在该分片中找不到对应数据</li></ul></li></ul><h3 id="5-3-2-全局id分片"><a href="#5-3-2-全局id分片" class="headerlink" title="5.3.2 全局id分片"></a>5.3.2 全局id分片</h3><p>当进行数据切分后，数据会存放在多张表中，如果仍然通过数据库自增id的方式，就会出现ID重复的问题，造成数据错乱。所以当拆分完数据后，需要让每一条数据都有自己的ID，并且在多表中不能出现重复。比较常见的会使用雪花算法来生成分布式id。</p><p>在Mycat中也提供了四种方式来进行分布式id生成：基于文件、基于数据库、基于时间戳和基于ZooKeeper。</p><p><strong>基于本地文件</strong></p><p><strong>优点：</strong></p><ul><li>本地加载，读取速度较快</li></ul><p><strong>缺点：</strong></p><ul><li><p>MyCAT重新发布后，配置文件中的sequence会初始化</p></li><li><p>生成的id没有意义</p></li><li><p>MyCat如果存在多个，会出现id重复冲突</p></li></ul><p><strong>流程:</strong></p><ol><li>修改<strong>sequence_conf.properties</strong>，<code>配置文件中注释一定呀删除</code></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">USER.HISIDS</span>=  <span class="string">#使用过的历史分段，可不配置</span></span><br><span class="line"><span class="attr">USER.MINID</span>=<span class="string">1  #最小ID值</span></span><br><span class="line"><span class="attr">USER.MAXID</span>=<span class="string">200000  #最大ID值</span></span><br><span class="line"><span class="attr">USER.CURID</span>=<span class="string">1000  #当前ID值</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改<strong>server.xml</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置全局序号生成方式</span></span><br><span class="line"><span class="comment">   0：文件</span></span><br><span class="line"><span class="comment">   1：数据库</span></span><br><span class="line"><span class="comment">   2：时间戳</span></span><br><span class="line"><span class="comment">   3：zookeeper</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--必须带有MYCATSEQ_或者 mycatseq_进入序列匹配流程 注意MYCATSEQ_有空格的情况--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequenceHandlerType&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequnceHandlerPattern&quot;</span>&gt;</span>(?:(\s*next\s+value\s+for\s*MYCATSEQ_(\w+))(,|\)|\s)*)+<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;subqueryRelationshipCheck&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span> <span class="comment">&lt;!-- 子查询中存在关联查询的情况下,检查关联字段中是否有分片字段 .默认 false --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequenceHanlderClass&quot;</span>&gt;</span>io.mycat.route.sequence.handler.HttpIncrSequenceHandler<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>测试:</strong></p><p>插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(user_id,user_name) <span class="keyword">values</span>(<span class="string">&#x27;next value for MYCATSEQ_USER&#x27;</span>,<span class="string">&#x27;wangwu&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>其他三种配置方式:</strong></p><ol><li>==<strong>数据库:</strong>==</li></ol><ul><li>执行dbseq.sql中的sql语句，执行完毕后，会创建一张表</li></ul><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200605191200321.png"></p><ul><li>修改sequence_db_conf.properties</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TB_USER=localdn #dataNode的name属性的名字</span><br></pre></td></tr></table></figure><ul><li><strong>修改server.xml文件</strong>，修改全局序列号生成方式为数据库方式</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequenceHandlerType&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改schema.xml, 在table中添加自增属性</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;localdn&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">subTables</span>=<span class="string">&quot;tb_user$1-3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span> <span class="attr">autoIncrement</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>执行语句</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(user_id,user_name) <span class="keyword">values</span>(<span class="string">&#x27;next value for MYCATSEQ_TB_USER&#x27;</span>,<span class="string">&#x27;wangwu&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>特点</p><ul><li>本地加载，读取速度较快</li></ul></li><li><p>当MyCAT重新发布后，配置文件中的sequence会恢复到初始值</p></li><li><p>生成的id没有含义，如时间</p></li><li><p>MyCat如果存在多个，会出现id重复问题</p></li></ul><ol start="2"><li>==<strong>zookeeper</strong>==</li></ol><ul><li>修改<strong>server.xml</strong>，更改生成模式</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequenceHandlerType&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改<strong>myid.properties</strong>，配置zk连接信息</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loadZk</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">zkURL</span>=<span class="string">192.168.200.131:2181</span></span><br><span class="line"><span class="attr">clusterId</span>=<span class="string">01</span></span><br><span class="line"><span class="attr">myid</span>=<span class="string">mycat_fz_01</span></span><br><span class="line"><span class="attr">clusterNodes</span>=<span class="string">mycat_fz_01</span></span><br></pre></td></tr></table></figure><ul><li>修改<strong>sequence_distributed_conf.properties</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSTANCEID=ZK #声明使用zk生成</span><br><span class="line">CLUSTERID=01</span><br></pre></td></tr></table></figure><ul><li>新增数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#MYCATSEQ_这个后缀可以随便写即可</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(user_id,user_name) <span class="keyword">values</span>(<span class="string">&#x27;next value for MYCATSEQ_TB_AAAA&#x27;</span>,<span class="string">&#x27;atguigu&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>特点<ul><li>ID 结构：<strong>long 64 位</strong>，ID 最大可占 63 位</li><li>可以承受单机房单机器单线程 1000*(2^6)=640000 的并发。</li><li>无悲观锁，无强竞争，吞吐量更高</li></ul></li></ul><ol start="3"><li><strong>==时间戳==</strong></li></ol><ul><li><p>修改<strong>server.xml</strong>。更改生成方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequenceHandlerType&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>修改<strong>sequence_time_conf.properties</strong></p></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sequence depend on TIME</span></span><br><span class="line"><span class="comment">#WORKID与DATAACENTERID: 0-31 任意整数。多mycat节点下，每个节点的WORKID、DATAACENTERID不能重复，组成唯一标识，总共支持32*32=1024 种组合</span></span><br><span class="line"><span class="attr">WORKID</span>=<span class="string">01</span></span><br><span class="line"><span class="attr">DATAACENTERID</span>=<span class="string">01</span></span><br></pre></td></tr></table></figure><ul><li><p>新增数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#MYCATSEQ_这个后缀可以随便写即可</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(user_id,user_name) <span class="keyword">values</span>(<span class="string">&#x27;next value for MYCATSEQ_TB_BBBB&#x27;</span>,<span class="string">&#x27;atguigu&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>特点</p><ul><li>不存在id重复的现象</li><li>数据类型太长，建议字段类型采用bigint(最大取值18446744073709551615)</li></ul></li></ul><h3 id="5-3-3-枚举分片"><a href="#5-3-3-枚举分片" class="headerlink" title="5.3.3 枚举分片"></a>5.3.3 枚举分片</h3><p>适用于在特定业务场景下，将不同的数据存放于不同的数据库中，如按省份存放订单、按存放人员信息等。</p><ol><li>修改<strong>schema.xml</strong>，修改<strong>table</strong>标签中<strong>name</strong>属性为当前操作的表名，<strong>rule</strong>属性为<strong>sharding-by-intfile</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user_sharding_by_intfile&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn129,dn130&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-intfile&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改<strong>rule.xml</strong>，配置<strong>tableRule</strong>为<strong>sharding-by-intfile</strong>中<strong>columns</strong>属性为当前指定分片字段</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-intfile&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>sex<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>修改<strong>rule.xml</strong>中<strong>hash-int</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;hash-int&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByFileMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--type默认值为0，0表示Integer，非零表示String--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;type&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--defaultNode 当有一些特殊数据信息可以存放于默认节点中，如即不是male也不是female。默认节点：小于0表示不设置默认节点，大于等于0表示设置默认节点,不能解析的枚举就存到默认节点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>修改<strong>partition-hash-int.txt</strong>。指定分片字段不同值存在于不同的数据库节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">male=0 #代表第一个datanode</span><br><span class="line">female=1 #代表第二个datanode</span><br></pre></td></tr></table></figure><ol start="5"><li><p>注意事项</p><p>==<strong>该方案适用于特定业务场景进行数据分片，但该方式容易出现数据倾斜，如不同省份的订单量一定会不同。订单量大的省份还会进行数据分库，数据库架构就会继续发生对应改变。</strong>==</p></li></ol><h3 id="5-3-4-固定hash分片"><a href="#5-3-4-固定hash分片" class="headerlink" title="5.3.4 固定hash分片"></a>5.3.4 固定hash分片</h3><p>固定hash分片的工作原理类似与redis cluster槽的概念，在固定hash中会有一个范围是0-1024，内部会进行二进制运算操作，如取 id 的二进制低10 位 与 1111111111 进行&amp;运算。从而当出现连接数据插入，其有可能会进入到同一个分片中，减少了分布式事务操作，提升插入效率同时尽量减少了数据倾斜问题，但不能避免不出现数据倾斜。</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200613210301026.png"></p><p>按照上面这张图就存在两个分区，partition1和partition2。partition1的范围是0-255，partition2的范围是256-1024。</p><p>当向分区中存数据时，先将id值转换为二进制，接着&amp;1111111111，再对结果值转换为十进制，从而确定当前数据应该存入哪个分区中。</p><ul><li>1023的二进制&amp;1111111111运算后为1023，故落入第二个分区 </li><li>1024的二进制&amp;1111111111运算后为0，故落入第一个分区</li><li>266 的二进制&amp;1111111111运算后为266，故落入第二个分区内</li></ul><ol><li>修改<strong>schema.xml</strong>，配置自定义固定hash分配规则</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user_fixed_hash&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn129,dn130&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;partition-by-fixed-hash&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改<strong>rule.xml</strong>，配置自定义固定hash分片规则</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;partition-by-fixed-hash&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>user_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>partition-by-fixed-hash<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  partitionCount: 存在多少个节点，如1,1    1,1,1</span></span><br><span class="line"><span class="comment">  partitionLength: 每个节点分配的范围大小</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;partition-by-fixed-hash&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByLong&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionCount&quot;</span>&gt;</span>1,1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionLength&quot;</span>&gt;</span>256,768<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>测试，添加数据，可以发现数据会根据计算，落入相应的数据库节点。</li></ol><h3 id="5-3-5-固定范围分片"><a href="#5-3-5-固定范围分片" class="headerlink" title="5.3.5 固定范围分片"></a>5.3.5 固定范围分片</h3><p>该规则有点像枚举与固定hash的综合体，设置某一个字段，然后规定该字段值的不同范围值会进入到哪一个dataNode。适用于明确知道分片字段的某个范围属于某个分片</p><p>优点：适用于想明确知道某个分片字段的某个范围具体在哪一个节点</p><p>缺点：如果短时间内有大量的批量插入操作，那么某个分片节点可能一下子会承受比较大的数据库压力，而别的分片节点此时可能处于闲置状态，无法利用其它节点进行分担压力（热点数据问题)</p><ol><li>修改<strong>schema.xml</strong>。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user_range&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn129,dn130&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改<strong>rule.xml</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto-sharding-long&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>age<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改<strong>autopartition-long.txt</strong>，定义自定义范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#用于定义dataNode对应的数据范围，如果配置多了会报错。</span><br><span class="line"># range start-end ,data node index</span><br><span class="line"># K=1000,M=10000.</span><br><span class="line">#0-500M=0</span><br><span class="line">#500M-1000M=1</span><br><span class="line">#1000M-1500M=2</span><br><span class="line"></span><br><span class="line">#所有的节点配置都是从0开始，0代表节点1</span><br><span class="line">0-20=0</span><br><span class="line">21-50=1</span><br></pre></td></tr></table></figure><ol start="4"><li>测试，添加用户信息，年龄分别为9和33</li></ol><h3 id="5-3-6-取模范围分片"><a href="#5-3-6-取模范围分片" class="headerlink" title="5.3.6 取模范围分片"></a>5.3.6 取模范围分片</h3><p>这种方式结合了范围分片和取模分片，主要是为后续的数据迁移做准备。</p><p>优点：可以自主决定取模后数据的节点分布</p><p>缺点：dataNode 划分节点是事先建好的，需要扩展时比较麻烦</p><ol><li>修改schema.xml，配置分片规则</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user_mod_range&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn129,dn130&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-partition&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改rule.xml，添加分片规则</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-partition&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>user_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-partition<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-partition&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByPattern&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--求模基数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;patternValue&quot;</span>&gt;</span>256<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认节点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定规则配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-pattern.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>添加partition-pattern.txt，文件内部配置节点中数据范围</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#0-128表示id%256后的数据范围。</span><br><span class="line">0-128=0</span><br><span class="line">129-256=1</span><br></pre></td></tr></table></figure><ol start="4"><li>测试</li></ol><h3 id="5-3-7-字符串hash分片"><a href="#5-3-7-字符串hash分片" class="headerlink" title="5.3.7 字符串hash分片"></a>5.3.7 字符串hash分片</h3><p>在业务场景下，有时可能会根据某个分片字段的前几个值来进行取模。如地址信息只取省份、姓名只取前一个字的姓等。此时则可以使用该种方式。</p><p>其工作方式与取模范围分片类型，该分片方式支持数值、符号、字母取模。</p><ol><li>修改schema.xml。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user_string_hash&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn129,dn130&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-string-hash&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改rule.xml，定义拆分规则</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-string-hash&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>user_name<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-string-hash-function<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-string-hash-function&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByPrefixPattern&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--求模基数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;patternValue&quot;</span>&gt;</span>256<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 截取的位数  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefixLength&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-pattern-string-hash.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>新建partition-pattern-string-hash.txt。指定数据分片节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0-128=0</span><br><span class="line">129-256=1</span><br></pre></td></tr></table></figure><p>4）运行后可以发现 ，不同的姓名取模后，会进入不同的分片节点。</p><h3 id="5-3-8-一致性hash-哈希环"><a href="#5-3-8-一致性hash-哈希环" class="headerlink" title="5.3.8 一致性hash(哈希环)"></a>5.3.8 一致性hash(哈希环)</h3><p>通过一致性hash分片可以最大限度的让数据均匀分布，但是均匀分布也会带来问题，就是分布式事务。</p><p><strong>原理(重点)</strong></p><p>一致性hash算法引入了hash环的概念。环的大小是0~2^32-1。首先通过crc16算法计算出数据节点在hash环中的位置。</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200614115947722.png"></p><p>当存储数据时，也会采用同样的算法，计算出数据key的hash值，映射到hash环上。</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200614120302675.png"></p><p>然后从数据映射的位置开始，以顺时针的方式找出距离最近的数据节点，接着将数据存入到该节点中。</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200614121047323.png"></p><p>此时可以发现，数据并没有达到预期的数据均匀，可以发现如果两个数据节点在环上的距离，决定有大量数据存入了dataNode2，而仅有少量数据存入dataNode1。</p><p>为了解决数据不均匀的问题，在mycat中可以设置<strong>虚拟数据映射节点</strong>。同时这些虚拟节点会映射到实际数据节点。</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200614121729209.png"></p><p>数据仍然以顺时针方式寻找数据节点，当找到最近的数据节点无论是实际还是虚拟，都会进行存储，如果是虚拟数据节点的话，最终会将数据保存到实际数据节点中。 从而尽量的使数据均匀分布。</p><p>实现流程如下:</p><ol><li><p>修改schema.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user_murmur&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn129,dn130&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-murmur&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改rule.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-murmur&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>user_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>murmur<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;murmur&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMurmurHash&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;seed&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 默认是0即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 要分片的数据库节点数量，必须指定，否则没法分片 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;virtualBucketTimes&quot;</span>&gt;</span>160<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的160倍 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name=&quot;weightMapFile&quot;&gt;weightMapFile&lt;/property&gt; 节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。所有权重值必须是正整数，否则以1代替 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name=&quot;bucketMapPath&quot;&gt;/etc/mycat/bucketMapPath&lt;/property&gt;</span></span><br><span class="line"><span class="comment">   用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的murmur hash值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试: 循环插入一千条数据，数据会尽量均匀的分布在两个节点中。</p></li></ol><h3 id="5-3-9-时间分片"><a href="#5-3-9-时间分片" class="headerlink" title="5.3.9 时间分片"></a>5.3.9 时间分片</h3><p>当数据量非常大时，有时会考虑，按天去分库分表。这种场景是非常常见的。同时也有利于后期的数据查询。</p><ol><li><p>修改schema.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user_day&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn129,dn130&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-date&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改rule.xml，每十天一个分片，从起始时间开始计算，分片不够，则报错。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-date&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>create_time<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>partbyday<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;partbyday&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByDate&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日期格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateFormat&quot;</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sNaturalDay&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--从哪天开始,并且只能插入2020年的数据，2021的无法插入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sBeginDate&quot;</span>&gt;</span>2020-01-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--每隔几天一个分片--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sPartionDay&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试: 当时间为1月1-10号之间，会进入129节点。当时间为11-20号之间，会进入130节点，当超出则报错。</p></li></ol><h2 id="5-4-跨库join"><a href="#5-4-跨库join" class="headerlink" title="5.4 跨库join"></a>5.4 跨库join</h2><h3 id="5-4-1-全局表"><a href="#5-4-1-全局表" class="headerlink" title="5.4.1 全局表"></a>5.4.1 全局表</h3><p>系统中基本都会存在数据字典信息，如数据分类信息、项目的配置信息等。这些字典数据最大的特点就是数据量不大并且很少会被改变。同时绝大多数的业务场景都会涉及到字典表的操作。 因此为了避免频繁的跨库join操作，结合冗余数据思想，可以考虑把这些字典信息在每一个分库中都存在一份。</p><p>mycat在进行join操作时，当业务表与全局表进行聚合会优先选择相同分片的全局表，从而避免跨库join操作。在进行数据插入时，会把数据同时插入到所有分片的全局表中。</p><p>1）修改<strong>schema.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_global&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn142,dn145&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;global_id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;global&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-2-ER表"><a href="#5-4-2-ER表" class="headerlink" title="5.4.2 ER表"></a>5.4.2 ER表</h3><p>ER表也是一种为了避免跨库join的手段，在业务开发时，经常会使用到主从表关系的查询，如商品表与商品详情表。</p><p>ER表的出现就是为了让有关系的表数据存储于同一个分片中，从而避免跨库join的出现。</p><ol><li>修改schema.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_goods&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn129,dn130&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;goods_id&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-murmur-goods&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_goods_detail&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;goods_detail_id&quot;</span> <span class="attr">joinKey</span>=<span class="string">&quot;goods_id&quot;</span> <span class="attr">parentKey</span>=<span class="string">&quot;goods_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">childTable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>再次添加goods数据的时候,有关系的表数据存储于同一个分片中</li></ol><h1 id="6-Mycat进阶"><a href="#6-Mycat进阶" class="headerlink" title="6 Mycat进阶"></a>6 Mycat进阶</h1><h2 id="6-1-读写分离"><a href="#6-1-读写分离" class="headerlink" title="6.1 读写分离"></a>6.1 读写分离</h2><p>一个数据库的容量毕竟是有限制的，如果数据量非常大，分表已经满足不了的话，就会进行分库操作。分库架构如下：</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/image-20200612002109456.png"></p><p>现在存在两个主库，并且各自都有从节点。 当插入数据时，根据id取模放入不同的库中。同时主从间在进行写时复制的同时，还要完成主从读写分离的配置。</p><ol><li>修改schema.xml。配置多datenode与datahost。同时配置主从读写分离。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;userDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn129&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;t_user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn129,dn130&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn129&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dh129&quot;</span> <span class="attr">database</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn130&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dh130&quot;</span> <span class="attr">database</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dh129&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;100&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span>  <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--查询心跳--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置写节点实际物理数据库信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://192.168.200.129:3306&quot;</span> <span class="attr">host</span>=<span class="string">&quot;host1&quot;</span>  <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置读节点实际物理数据库信息--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://192.168.200.130:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dh130&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;100&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span>  <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--查询心跳--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置写节点实际物理数据库信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://192.168.200.129:3306&quot;</span> <span class="attr">host</span>=<span class="string">&quot;host1&quot;</span>  <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置读节点实际物理数据库信息--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://192.168.200.130:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改rule.xml。配置取模时的模数</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据datanode数量进行取模分片，也就是要模几。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>读写分离验证</li></ol><p>​    设置log4j2.xml的日志级别为DEBUG</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">........</span><br><span class="line">        <span class="tag">&lt;<span class="name">asyncRoot</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">includeLocation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">........</span><br><span class="line">        <span class="tag">&lt;/<span class="name">asyncRoot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基于mysql服务进行数据查看，观察控制台信息，可以看到对于read请求的数据源，分别使用的是配置文件的配置</p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/../../../%E7%BD%91%E9%A1%B5%E4%B8%8B%E8%BD%BD/dell/day3/%E8%AF%BE%E4%BB%B6/image/image-20200621213109545.png"></p><p><img src="/2022/12/06/MySQL%E9%9B%86%E7%BE%A4/../../../%E7%BD%91%E9%A1%B5%E4%B8%8B%E8%BD%BD/dell/day3/%E8%AF%BE%E4%BB%B6/image/image-20200621213153827.png"></p><h2 id="6-2-主从切换"><a href="#6-2-主从切换" class="headerlink" title="6.2 主从切换"></a>6.2 主从切换</h2><p>基于Mycat主从复制方案，当前存在一个主节点和一个从节点，主节点负责写操作，从节点负责读操作。当在一个dataHost中配置了两个或多个writeHost，如果第一个writeHost宕机，则Mycat会在默认3次心跳检查失败后，自动切换到下一个可用的writeHost执行DML语句，并在<strong>conf/dnindex.properties</strong>文件里记录当前所用的writeHost的index。</p><p>在Mycat主从切换中，可以将从节点也配置为是一个写节点（相当于从节点同时负责读写）。当原有的master写节点宕机后，从节点会被提升为主节点，同时负责读写操作。当写节点恢复后，会被作为从节点使用，保持现有状态不变，跟随新的主节点。</p><p><strong>简单点说就是：原来的主变成从，原来的从一直为主。</strong></p><p>schema.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;userDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn142&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn142&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;user_id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn142&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dh142&quot;</span> <span class="attr">database</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">writeType:0  所有的写操作都发送到writeHost上</span></span><br><span class="line"><span class="comment">balance:1 所有读操作都发送到readHost上</span></span><br><span class="line"><span class="comment">switchType:2 基于mysql主从同步的状态决定是否切换</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dh142&quot;</span>  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;100&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span>  <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--查询心跳--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>show slave status<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置写节点实际物理数据库信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://192.168.200.142:3309&quot;</span> <span class="attr">host</span>=<span class="string">&quot;host1&quot;</span>  <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置读节点实际物理数据库信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://192.168.200.145:3309&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置从节点也会作为写节点使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://192.168.200.145:3309&quot;</span> <span class="attr">host</span>=<span class="string">&quot;host2&quot;</span>  <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试: </p><ul><li><p>开启host1和host2</p><p>结论: 新增数据,全部新增到了host1中</p></li><li><p>关闭host1</p><p>结论: 新增数据,全部新增到了host2中</p></li><li><p>再次开启host1</p><p>结论: 新增数据,依然新增到host2中</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL-集群&quot;&gt;&lt;a href=&quot;#MySQL-集群&quot; class=&quot;headerlink&quot; title=&quot;MySQL 集群&quot;&gt;&lt;/a&gt;MySQL 集群&lt;/h1&gt;&lt;h1 id=&quot;mysql集群&quot;&gt;&lt;a href=&quot;#mysql集群&quot; class=&quot;header</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL集群" scheme="http://example.com/tags/MySQL%E9%9B%86%E7%BE%A4/"/>
    
    <category term="MySQL高可用" scheme="http://example.com/tags/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
    <category term="数据分片" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/"/>
    
    <category term="Mycat工具" scheme="http://example.com/tags/Mycat%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>MySQL高级</title>
    <link href="http://example.com/2022/12/04/MySQL%E9%AB%98%E7%BA%A7/"/>
    <id>http://example.com/2022/12/04/MySQL%E9%AB%98%E7%BA%A7/</id>
    <published>2022-12-04T10:53:47.000Z</published>
    <updated>2022-12-06T07:10:42.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><ul><li>MySQL的索引（理论）</li><li>如何让索引生效？（理论）—&gt;这个索引生效还是未生效？（操作）</li></ul><h2 id="1-Explain"><a href="#1-Explain" class="headerlink" title="1. Explain"></a>1. Explain</h2><p>MySQL中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间）</p><p>当客户端向MySQL 请求一条Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给MySQL Query Optimizer时，MySQL Query Optimizer 首先会对整条Query进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息（如果有），看显示Hint信息是否可以完全确定该Query 的执行计划。如果没有 Hint 或Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。 </p><h2 id="1-1-Explain简介"><a href="#1-1-Explain简介" class="headerlink" title="1.1 Explain简介"></a>1.1 Explain简介</h2><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是 如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p><p>EXPLAIN功能: 表的读取顺序，数据读取操作的操作类型，哪些索引可以使用，哪些索引被实际使用，表之间的引用，每张表有多少行被优化器查询等内容。</p><p>使用方式为：Explain + SQL语句</p><p>EXPLAIN出来的信息有10列，分别是<strong>id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</strong></p><p><strong>id: 选择标识符</strong></p><p><strong>select_type: 表示查询的类型</strong></p><p><strong>table: 输出结果集的表</strong></p><p><strong>partitions: 匹配的分区</strong></p><p><strong>type: 表示表的连接类型</strong></p><p><strong>possible_keys: 表示查询时，可能使用的索引</strong></p><p><strong>key: 表示实际使用的索引</strong></p><p><strong>key_len: 索引字段的长度</strong></p><p><strong>ref: 列与索引的比较</strong></p><p><strong>rows: 扫描出的行数(估算的行数)</strong></p><p><strong>filtered: 按表条件过滤的行百分比</strong></p><p><strong>Extra: 执行情况的描述和说明</strong></p><p>创建一下数据库表和数据，接下来进行explain的详细学习</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT,content  <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span> ,  <span class="keyword">PRIMARY</span> KEY (id));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT,content  <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span> ,  <span class="keyword">PRIMARY</span> KEY (id));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT,content  <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span> ,  <span class="keyword">PRIMARY</span> KEY (id));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t4(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT,content  <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span> ,  <span class="keyword">PRIMARY</span> KEY (id));</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1(content) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t1_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>))); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t2(content) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t2_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)));  </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t3(content) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t3_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)));    </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t4(content) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t4_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)));</span><br></pre></td></tr></table></figure><h3 id="1-1-1-id"><a href="#1-1-1-id" class="headerlink" title="1.1.1 id"></a>1.1.1 id</h3><p>select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序, 三种情况</p><ul><li>id相同，执行顺序由上至下 </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1,t2,t3,t4</span><br></pre></td></tr></table></figure><ul><li>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行 </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span></span><br><span class="line">t1.id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">t1 </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t1.id <span class="operator">=</span> ( <span class="keyword">SELECT</span> t2.id <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> t2.id <span class="operator">=</span> ( <span class="keyword">SELECT</span> t3.id <span class="keyword">FROM</span> t3 <span class="keyword">WHERE</span> t3.content <span class="operator">=</span> <span class="string">&#x27;t3_354&#x27;</span> ) )</span><br></pre></td></tr></table></figure><ul><li>id相同，不同，同时存在</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span></span><br><span class="line">t1.id,</span><br><span class="line">(<span class="keyword">select</span> t4.id <span class="keyword">from</span> t4 <span class="keyword">where</span> t4.id <span class="operator">=</span> t1.id)id4</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">t1,t2</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><strong>id如果相同，可以认为是一组，从上往下顺序执行</strong></li><li><strong>在所有组中，id值越大，优先级越高，越先执行</strong> </li><li><strong>id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</strong></li></ul><h3 id="1-1-2-select-type"><a href="#1-1-2-select-type" class="headerlink" title="1.1.2 select_type"></a>1.1.2 select_type</h3><p><strong>SIMPLE</strong> : 简单的 select 查询,查询中不包含子查询或者UNION</p><p><strong>PRIMARY</strong> :查询中若包含任何复杂的子部分，最外层查询则被标记为primary</p><p><strong>SUBQUERY</strong>: 在SELECT或WHERE列表中包含了子查询</p><p><strong>DEPENDENT SUBQUERY</strong>: 在SELECT或WHERE列表中包含了子查询,子查询基于外层</p><p><strong>UNCACHEABLE SUBQUREY</strong>: 表示这个subquery的查询要受到外部表查询的影响</p><p><strong>DERIVED</strong>: 在FROM列表中包含的子查询被标记为DERIVED(衍生) MySQL会递归执行这些子查询, 把结果放在临时表里</p><p><strong>UNION</strong>: 这是UNION语句其中的一个SQL元素 （union和union all : 联合数据，并且去重，字段名和数量相同;union all 不去重）</p><p><strong>UNION RESULT</strong>: 从UNION表获取结果的SELECT （去重操作返回的临时表）</p><h3 id="1-1-3-table"><a href="#1-1-3-table" class="headerlink" title="1.1.3 table"></a>1.1.3 table</h3><p>显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称</p><h3 id="1-1-4-partitions"><a href="#1-1-4-partitions" class="headerlink" title="1.1.4 partitions"></a>1.1.4 partitions</h3><p>代表分区表中的命中情况，非分区表，该项为null</p><h3 id="1-1-5-type-效率"><a href="#1-1-5-type-效率" class="headerlink" title="1.1.5 type(效率)"></a>1.1.5 <code>type</code>(效率)</h3><p>对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。</p><p>常用的类型有： <strong>ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）</strong></p><p><strong>ALL</strong>: Full Table Scan， MySQL将遍历全表以找到匹配的行（<code>全表扫描，扫描所有的子节点</code>）</p><p><strong>index</strong>: Full Index Scan，index与ALL区别为index类型只遍历索引树, all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的 （<code>扫描所有的非叶子节点，即索引</code>）</p><p><strong>range</strong>: 只检索给定范围的行，使用一个索引来选择行, <strong>范围索引扫描比全表扫描要好</strong>，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引 （<code>查询的基础级别，查询部分非叶子节点，即查询范围内的索引</code>）</p><p><strong>ref</strong>:  表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 （<code>命中部分索引</code>）</p><p><strong>eq_ref</strong>: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件（<code>完全命中索引</code>）</p><p><code>非常用级别以下</code></p><p><strong>const</strong>: 表示通过索引一次就找到了,const用于primary key或者unique索引, 因为只匹配一行数据，所以很快 如将主键置于where列表中，MySQL就能将该查询转换为一个常量</p><p><strong>system</strong>: 表仅有一行记录，这是const类型的特例，查询起来非常迅速</p><p><strong>NULL</strong>: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p><p><strong>index_merge</strong>:在查询过程中需要多个索引组合使用，通常出现在有 or 的关键字的sql中</p><p><strong>ref_or_null</strong>:  对于某个字段既需要关联条件，也需要null值得情况下。查询优化器会选择用ref_or_null连接查询。</p><p><strong>index_subquery</strong>:利用索引来关联子查询，不再全表扫描</p><p><strong>unique_subquery</strong> :该联接类型类似于index_subquery, 子查询中的唯一索引</p><p> <strong>备注：一般来说，得保证查询至少达到range级别，最好能达到ref。</strong> </p><h3 id="1-1-6-possible-keys"><a href="#1-1-6-possible-keys" class="headerlink" title="1.1.6 possible_keys"></a>1.1.6 possible_keys</h3><p>指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）</p><h3 id="1-1-7-key"><a href="#1-1-7-key" class="headerlink" title="1.1.7 key"></a>1.1.7 key</h3><p>key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中</p><h3 id="1-1-8-key-len"><a href="#1-1-8-key-len" class="headerlink" title="1.1.8 key_len"></a>1.1.8 key_len</h3><p>key_len表示索引使用的字节数，根据这个值可以判断索引的使用情况，特别是在组合索引的时候，判断该索引有多少部分被使用到非常重要, 值越小索引的效果越好。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> t3(content);</span><br></pre></td></tr></table></figure><p><strong>计算逻辑:</strong> </p><ul><li><p>先看索引上字段的类型+长度比如 int=4 ; varchar(20) =20 ; char(20) =20 </p></li><li><p>如果是varchar或者char这种字符串字段，视字符集要乘不同的值，比如utf-8要乘 3，GBK要乘2</p></li><li><p>varchar这种动态字符串要加2个字节</p></li><li><p>允许为空的字段要加1个字节 </p><p><strong>复合索引：多个列为索引（最左原则，最有原则)</strong></p><ul><li>最左原则：查询条件（where）必须依次索引设定来查询（服务器会进行SQL优化,尽量保持一直必变优化，浪费性能），依次匹配会进行部分命中和全部命中，当全部不命中时则索引失效。- <ul><li>int型字段，长度为4（因为int为4字节）</li><li>varchar类型字段：为设置的长度*编码集的字节数^（例如：utf-8：3字节，GTK:2字节）^ +是否为允许为null（是：1，否：0）+2^(varchar为动态字符)^     &gt; 例如varchar(20) = 20 * 3 + 1 + 2 = 73 </li></ul></li><li>最右原则：查询条件中包含一个字段进行 &gt; 和 &lt; 筛选时，这个字段索引应该放在最右面</li></ul></li></ul><h3 id="1-1-9-ref"><a href="#1-1-9-ref" class="headerlink" title="1.1.9 ref"></a>1.1.9 ref</h3><p>显示将哪些列或常量与键列中命名的索引进行比较，以从表中选择行</p><h3 id="1-1-10-rows"><a href="#1-1-10-rows" class="headerlink" title="1.1.10 rows"></a>1.1.10 rows</h3><p> 估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p><h3 id="1-1-11-filtered"><a href="#1-1-11-filtered" class="headerlink" title="1.1.11 filtered"></a>1.1.11 filtered</h3><p>这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，<strong>注意是百分比，不是具体记录数</strong></p><h3 id="1-1-12-Extra（附加数据）"><a href="#1-1-12-Extra（附加数据）" class="headerlink" title="1.1.12 Extra（附加数据）"></a>1.1.12 Extra（附加数据）</h3><p>该列包含MySQL解决查询的详细信息,有以下几种情况：</p><p>**Using where:**不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p><p><strong>Using temporary</strong>：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p><p><strong>Using filesort</strong>：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”（<code>出现文件排序是因为排序字段不是索引字段，尽量减少文件排序多使用索引字段进行排序，也可以使用java排序，java排序比文件排序效率高</code>）</p><p><strong>Using join buffer</strong>：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p><p><strong>Impossible where</strong>：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</p><p><strong>Select tables optimized away</strong>：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p><p><strong>No tables used</strong>：Query语句中使用from dual 或不含任何from子句</p><h2 id="1-2-注意事项"><a href="#1-2-注意事项" class="headerlink" title="1.2 注意事项"></a>1.2 注意事项</h2><ul><li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li><li>EXPLAIN不考虑各种Cache</li><li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li><li>部分统计信息是估算的，并非精确值</li><li>EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划</li></ul><h1 id="2-数据准备"><a href="#2-数据准备" class="headerlink" title="2 数据准备"></a>2 数据准备</h1><h2 id="2-1-建表"><a href="#2-1-建表" class="headerlink" title="2.1 建表"></a>2.1 建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept` (</span><br><span class="line"> `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `deptName` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `address` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `ceo` <span class="type">INT</span> <span class="keyword">NULL</span> ,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `emp` (</span><br><span class="line"> `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `empno` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line"> `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `deptId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line"> #<span class="keyword">CONSTRAINT</span> `fk_dept_id` <span class="keyword">FOREIGN</span> KEY (`deptId`) <span class="keyword">REFERENCES</span> `t_dept` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-2-设置参数"><a href="#2-2-设置参数" class="headerlink" title="2.2 设置参数"></a>2.2 设置参数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建函数，假如报错：This <span class="keyword">function</span> has <span class="keyword">none</span> <span class="keyword">of</span> DETERMINISTIC......</span><br><span class="line"># 由于开启过慢查询日志bin<span class="operator">-</span>log, 我们就必须为我们的<span class="keyword">function</span>指定一个参数。</span><br><span class="line">#主从复制，主机会将写操作记录在bin<span class="operator">-</span>log日志中。从机读取bin<span class="operator">-</span>log日志，执行语句来同步数据。</span><br><span class="line">#如果使用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql不开启创建函数设置</span><br><span class="line">#查看mysql是否允许创建函数：</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_bin_trust_function_creators&#x27;</span>;</span><br><span class="line">#命令开启：允许创建函数设置：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>; </span><br><span class="line"># 不加<span class="keyword">global</span>只是当前窗口有效。mysqld重启，上述参数又会消失。</span><br><span class="line">#永久方法：</span><br><span class="line">•windows下：my.ini[mysqld]加上：log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>  </span><br><span class="line">•linux下：<span class="operator">/</span>etc<span class="operator">/</span>my.cnf下my.cnf[mysqld]加上：log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="2-3-创建函数"><a href="#2-3-创建函数" class="headerlink" title="2.3 创建函数"></a>2.3 创建函数</h2><p>随机产生字符串</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line"><span class="keyword">BEGIN</span>    </span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">WHILE i <span class="operator">&lt;</span> n DO  </span><br><span class="line"><span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));  </span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"> </span><br><span class="line">#假如要删除</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> rand_string;</span><br></pre></td></tr></table></figure><p>随机产生部门编号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#用于随机产生多少到多少的编号</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span>  rand_num (from_num <span class="type">INT</span> ,to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span>   </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span> from_num<span class="operator">+</span><span class="number">1</span>))   ;</span><br><span class="line"><span class="keyword">RETURN</span> i;  </span><br><span class="line"><span class="keyword">END</span>$$ </span><br><span class="line"> </span><br><span class="line">#假如要删除</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> rand_num;</span><br></pre></td></tr></table></figure><h2 id="2-4-创建存储过程"><a href="#2-4-创建存储过程" class="headerlink" title="2.4 创建存储过程"></a>2.4 创建存储过程</h2><p>创建往emp表中插入数据的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span>  insert_emp(  <span class="keyword">START</span> <span class="type">INT</span> ,  max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;   </span><br><span class="line"> <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    #设置手动提交事务</span><br><span class="line"> REPEAT  #循环</span><br><span class="line"> <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;  #赋值</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (empno, NAME ,age ,deptid ) <span class="keyword">VALUES</span> ((<span class="keyword">START</span><span class="operator">+</span>i),rand_string(<span class="number">6</span>),rand_num(<span class="number">30</span>,<span class="number">50</span>),rand_num(<span class="number">1</span>,<span class="number">10000</span>));  </span><br><span class="line"> UNTIL i <span class="operator">=</span> max_num  </span><br><span class="line"> <span class="keyword">END</span> REPEAT;  </span><br><span class="line"> <span class="keyword">COMMIT</span>;  #提交事务</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line"> </span><br><span class="line">#删除</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PROCEDURE</span> insert_emp;</span><br></pre></td></tr></table></figure><p>创建往dept表中插入数据的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往dept表添加随机数据</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `insert_dept`(  max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;   </span><br><span class="line"> <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line"> REPEAT  </span><br><span class="line"> <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;  </span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept ( deptname,address,ceo ) <span class="keyword">VALUES</span> (rand_string(<span class="number">8</span>),rand_string(<span class="number">10</span>),rand_num(<span class="number">1</span>,<span class="number">500000</span>));  </span><br><span class="line"> UNTIL i <span class="operator">=</span> max_num  </span><br><span class="line"> <span class="keyword">END</span> REPEAT;  </span><br><span class="line"> <span class="keyword">COMMIT</span>; </span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line"> </span><br><span class="line">#删除</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PROCEDURE</span> insert_dept;</span><br></pre></td></tr></table></figure><p>删除表上所有索引的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">PROCEDURE</span> `proc_drop_index`(dbname <span class="type">VARCHAR</span>(<span class="number">200</span>),tablename <span class="type">VARCHAR</span>(<span class="number">200</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">       <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> ct <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> _index <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> _cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span>  <span class="keyword">SELECT</span>   index_name   <span class="keyword">FROM</span> information_schema.STATISTICS   <span class="keyword">WHERE</span> table_schema<span class="operator">=</span>dbname <span class="keyword">AND</span> table_name<span class="operator">=</span>tablename <span class="keyword">AND</span> seq_in_index<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span>    index_name <span class="operator">&lt;&gt;</span><span class="string">&#x27;PRIMARY&#x27;</span>  ;</span><br><span class="line">#每个游标必须使用不同的<span class="keyword">declare</span> continue handler <span class="keyword">for</span> <span class="keyword">not</span> found <span class="keyword">set</span> done<span class="operator">=</span><span class="number">1</span>来控制游标的结束</span><br><span class="line">       <span class="keyword">DECLARE</span>  CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">set</span> done<span class="operator">=</span><span class="number">2</span> ;      </span><br><span class="line">#若没有数据返回,程序继续,并将变量done设为<span class="number">2</span></span><br><span class="line">        <span class="keyword">OPEN</span> _cur;</span><br><span class="line">        <span class="keyword">FETCH</span> _cur <span class="keyword">INTO</span> _index;</span><br><span class="line">        WHILE  _index<span class="operator">&lt;&gt;</span><span class="string">&#x27;&#x27;</span> DO </span><br><span class="line">               <span class="keyword">SET</span> <span class="variable">@str</span> <span class="operator">=</span> CONCAT(&quot;drop index &quot; , _index , &quot; on &quot; , tablename ); </span><br><span class="line">               <span class="keyword">PREPARE</span> sql_str <span class="keyword">FROM</span> <span class="variable">@str</span> ;</span><br><span class="line">               <span class="keyword">EXECUTE</span>  sql_str;</span><br><span class="line">               <span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> sql_str;</span><br><span class="line">               <span class="keyword">SET</span> _index<span class="operator">=</span><span class="string">&#x27;&#x27;</span>; </span><br><span class="line">               <span class="keyword">FETCH</span> _cur <span class="keyword">INTO</span> _index; </span><br><span class="line">        <span class="keyword">END</span> WHILE;</span><br><span class="line">   <span class="keyword">CLOSE</span> _cur;</span><br><span class="line"><span class="keyword">END</span>$$</span><br></pre></td></tr></table></figure><h2 id="2-5-调用存储过程"><a href="#2-5-调用存储过程" class="headerlink" title="2.5 调用存储过程"></a>2.5 调用存储过程</h2><p>Dept</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往dept表添加<span class="number">1</span>万条数据  </span><br><span class="line"><span class="keyword">CALL</span> insert_dept(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p>Emp</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往emp表添加<span class="number">50</span>万条数据  </span><br><span class="line"><span class="keyword">CALL</span> insert_emp(<span class="number">100000</span>,<span class="number">500000</span>);</span><br></pre></td></tr></table></figure><h1 id="3-SQL优化"><a href="#3-SQL优化" class="headerlink" title="3 SQL优化"></a>3 SQL优化</h1><h2 id="3-1-索引失效"><a href="#3-1-索引失效" class="headerlink" title="3.1 索引失效"></a>3.1 索引失效</h2><h3 id="3-3-1-全值匹配"><a href="#3-3-1-全值匹配" class="headerlink" title="3.3.1 全值匹配"></a>3.3.1 全值匹配</h3><p>系统中经常出现的sql语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">and</span> deptid<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">and</span> deptid<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>思考: 索引应该如何建立 ？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> emp(age); #单值索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_deptid <span class="keyword">ON</span> emp(age,deptid);#复合索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_deptid_name <span class="keyword">ON</span> emp(age,deptid,NAME);#复合索引</span><br></pre></td></tr></table></figure><h3 id="3-3-2-最左法则"><a href="#3-3-2-最左法则" class="headerlink" title="3.3.2 最左法则"></a>3.3.2 最左法则</h3><p>如果系统经常出现的sql如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span> ;</span><br><span class="line">或者</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.deptid<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>; </span><br></pre></td></tr></table></figure><p> <strong>思考: 那原来的idx_age_deptid_name 还能否正常使用？</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptid<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>; </span><br></pre></td></tr></table></figure><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p><p>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#全值匹配</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">and</span> deptid<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">and</span> deptid<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#索引创建三种方案（<span class="number">1.</span>单值索引 <span class="number">2.</span>两列复合查询 <span class="number">3.</span>三列复合查询）</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> emp(age);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_deptid <span class="keyword">ON</span> emp(age,deptid);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_deptid_name <span class="keyword">ON</span> emp(age,deptid,NAME);</span><br><span class="line"></span><br><span class="line">#删除索引</span><br><span class="line"><span class="keyword">drop</span> index idx_age <span class="keyword">ON</span> emp;</span><br><span class="line"><span class="keyword">drop</span> index idx_age_deptid <span class="keyword">ON</span> emp;</span><br><span class="line"><span class="keyword">drop</span> index idx_age_deptid_name <span class="keyword">ON</span> emp;</span><br><span class="line"></span><br><span class="line">#索引命中规则为最左法则，部门命中或者全部命中，多个索引时命中百分比高的索引树优先采用，</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptid<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">#最左法则，第一个查询字段必须和索引的第一个字段相同，否则索引失效</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span><span class="keyword">and</span> deptid<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">#查询字段为复合索引字段所有字段时，<span class="keyword">sql</span>服务层会优化查询顺序为索引字段查询顺序（尽量避免顺序错乱）</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">and</span> deptid<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">#查询字段为复合索引字段的子集时，顺序相同时所有查询字段命中</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line">#查询字段为复合索引字段的子集时，顺序不相同时左边字段对应复合索引位置的字段才命中</span><br></pre></td></tr></table></figure><h3 id="3-3-3-计算、函数"><a href="#3-3-3-计算、函数" class="headerlink" title="3.3.3 计算、函数"></a>3.3.3 计算、函数</h3><p>模糊查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#创建索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> emp(NAME);</span><br><span class="line">#普通<span class="keyword">like</span>:可以触发索引<span class="operator">/</span>也可能会失效(后面会讲到,注意<span class="operator">%</span>为前缀匹配)</span><br><span class="line">#前缀查询，索引生效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line">#<span class="operator">%</span>放在中间查询，索引生效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%qw&#x27;</span>;</span><br><span class="line">#<span class="operator">%</span>放在最前面查询，索引完全失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">LIKE</span> <span class="string">&#x27;%qw&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#函数模糊查询: 索引完全失效 subString（截取查询，<span class="keyword">LEFT</span>(emp.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>，name的左边三个字母为abc）</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(emp.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>; </span><br><span class="line">#删除索引</span><br><span class="line"><span class="keyword">drop</span> INDEX idx_name <span class="keyword">ON</span> emp;</span><br></pre></td></tr></table></figure><h3 id="3-3-4-范围条件"><a href="#3-3-4-范围条件" class="headerlink" title="3.3.4 范围条件"></a>3.3.4 范围条件</h3><p>出现的sql如下：（查询条件中出现大于或者小于判断时,一般只有一个字段进行大小于判断）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#索引 idx_age_deptid_name这个索引还能正常使用么？不能，范围右边的列不能使用（部分命中）</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> emp.deptId<span class="operator">&gt;</span><span class="number">20</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> ; </span><br></pre></td></tr></table></figure><p>索引优化:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将范围查询条件放置语句最后</span><br><span class="line"><span class="keyword">create</span> index idx_age_name_deptid <span class="keyword">on</span> emp(age,name,deptid);</span><br></pre></td></tr></table></figure><p> <strong>注意: 应用开发中范围查询，例如： 金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。</strong> </p><h3 id="3-3-5-非-（否定条件查询，索引完全失效（-和-lt-gt-都表示非））"><a href="#3-3-5-非-（否定条件查询，索引完全失效（-和-lt-gt-都表示非））" class="headerlink" title="3.3.5 非 （否定条件查询，索引完全失效（!= 和 &lt;&gt;都表示非））"></a>3.3.5 非 （否定条件查询，索引完全失效（!= 和 &lt;&gt;都表示非））</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#为name字段创建索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> emp(NAME);</span><br><span class="line">#执行查看索引是否失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="operator">&lt;&gt;</span> <span class="string">&#x27;abc&#x27;</span> ;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="operator">!=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-6-is-not-null与is-null"><a href="#3-3-6-is-not-null与is-null" class="headerlink" title="3.3.6 is not null与is null"></a>3.3.6 is not null与is null</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">IS</span> <span class="keyword">NULL</span>:可以触发索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NULL</span>; </span><br><span class="line">#<span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>:无法触发索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-7-like"><a href="#3-3-7-like" class="headerlink" title="3.3.7 like"></a>3.3.7 like</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#下列哪个<span class="keyword">sql</span>语句可以用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;ab%&#x27;</span>; </span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%ab%&#x27;</span>; </span><br></pre></td></tr></table></figure><h3 id="3-3-8-类型转换"><a href="#3-3-8-类型转换" class="headerlink" title="3.3.8 类型转换"></a>3.3.8 类型转换</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#下列哪个<span class="keyword">sql</span>语句可以用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="number">123</span>; </span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;123&#x27;</span>; </span><br></pre></td></tr></table></figure><h3 id="3-3-9-小结"><a href="#3-3-9-小结" class="headerlink" title="3.3.9 小结"></a>3.3.9 小结</h3><p>假设index(a,b,c)</p><table><thead><tr><th>Where语句</th><th>索引是否被使用</th></tr></thead><tbody><tr><td>where a =  3</td><td>Y,使用到a</td></tr><tr><td>where a =  3 and b = 5</td><td>Y,使用到a，b</td></tr><tr><td>where a =  3 and b = 5 and c = 4</td><td>Y,使用到a,b,c</td></tr><tr><td>where b =  3 或者 where b = 3 and c =  4 或者 where c =  4</td><td>N</td></tr><tr><td>where a =  3 and c = 5</td><td>使用到a， 但是c不可以，b中间断了</td></tr><tr><td>where a =  3 and b &gt; 4 and c = 5</td><td>使用到a和b， c不能用在范围之后，b断了</td></tr><tr><td>where a is  null and b is not null</td><td>is null 支持索引  但是is not null 不支持,所以 a 可以使用索引,但是 b不可以使用</td></tr><tr><td>where a  &lt;&gt; 3</td><td>不能使用索引</td></tr><tr><td>where  abs(a) =3</td><td>不能使用 索引</td></tr><tr><td>where a =  3 and b like ‘kk%’ and c = 4</td><td>Y,使用到a,b,c</td></tr><tr><td>where a =  3 and b like ‘%kk’ and c = 4</td><td>Y,只用到a</td></tr><tr><td>where a =  3 and b like ‘%kk%’ and c = 4</td><td>Y,只用到a</td></tr><tr><td>where a =  3 and b like ‘k%kk%’ and c =  4</td><td>Y,使用到a,b,c</td></tr></tbody></table><p><strong>索引创建原则:</strong></p><ul><li>对于单键索引，尽量选择过滤性更好的索引（例如：手机号，邮件，身份证）</li><li>在选择组合索引的时候，过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>选择组合索引时，尽量包含where中更多字段的索引</li><li>组合索引出现范围查询时，尽量把这个字段放在索引次序的最后面</li><li>尽量避免造成索引失效的情况</li></ul><h2 id="3-2-关联查询优化"><a href="#3-2-关联查询优化" class="headerlink" title="3.2 关联查询优化"></a>3.2 关联查询优化</h2><h3 id="3-2-1-数据准备"><a href="#3-2-1-数据准备" class="headerlink" title="3.2.1 数据准备"></a>3.2.1 数据准备</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#分类</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `class` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`card` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br><span class="line">#图书</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `book` (</span><br><span class="line">`bookid` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`card` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`bookid`)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br></pre></td></tr></table></figure><h3 id="3-2-2-left-right-join"><a href="#3-2-2-left-right-join" class="headerlink" title="3.2.2 left/right join"></a>3.2.2 left/right join</h3><p>下面开始explain分析</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> class <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> class.card <span class="operator">=</span> book.card;</span><br></pre></td></tr></table></figure><p>结论：type 有All      </p><p>添加索引优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> INDEX Y (card); </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> class <span class="keyword">ADD</span> INDEX X (card); </span><br></pre></td></tr></table></figure><h3 id="3-2-3-inner-join"><a href="#3-2-3-inner-join" class="headerlink" title="3.2.3 inner join"></a>3.2.3 inner join</h3><p>换成inner join（MySQL自动选择驱动表）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN  <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span>  class <span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> class.card<span class="operator">=</span>book.card;</span><br></pre></td></tr></table></figure><p>添加索引优化  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> INDEX Y (card);         </span><br><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">TABLE</span> class <span class="keyword">ADD</span> INDEX X (card);</span><br></pre></td></tr></table></figure><p>dept表和emp表的关联查询优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#关联查询优化 </span><br><span class="line">#左连接查询（左表为驱动表，右表为被驱动表）</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE dept.<span class="operator">*</span>,emp.`name` <span class="keyword">FROM</span> dept <span class="keyword">left</span> <span class="keyword">join</span> emp <span class="keyword">on</span> emp.deptId <span class="operator">=</span> dept.id;</span><br><span class="line">#直接查询，发现type中有<span class="keyword">ALL</span>，查询效率低下</span><br><span class="line">#进行索引优化（驱动表尽量选择数据量少的表作为驱动表,把被驱动表查询字段作为索引）(左右连接优化方式相同)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> index emp_deptId(deptId);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> dept <span class="keyword">add</span> index dept_id(id);</span><br><span class="line"></span><br><span class="line">#<span class="keyword">inner</span> <span class="keyword">join</span>查询，看似没有被驱动表，<span class="keyword">sql</span>优化器会自动选择数据量小的表做驱动表</span><br><span class="line">#索引优化，两个表的字段都添加索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE dept.<span class="operator">*</span>,emp.`name` <span class="keyword">FROM</span> dept <span class="keyword">inner</span> <span class="keyword">join</span> emp <span class="keyword">on</span> emp.deptId <span class="operator">=</span> dept.id;</span><br><span class="line">#进行索引优化</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> index emp_deptId(deptId);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> dept <span class="keyword">add</span> index dept_id(id);</span><br></pre></td></tr></table></figure><h3 id="3-2-4-小结"><a href="#3-2-4-小结" class="headerlink" title="3.2.4 小结"></a>3.2.4 小结</h3><ul><li>保证被驱动表的join字段被索引</li><li>left join 时，选择小表作为驱动表，大表作为被驱动表</li><li>inner join 时，mysql会自动将小结果集的表选为驱动表。</li><li>子查询尽量不要放在被驱动表，衍生表建不了索引</li><li>能够直接多表关联的尽量直接关联，不用子查询</li></ul><h2 id="3-3-子查询优化"><a href="#3-3-子查询优化" class="headerlink" title="3.3 子查询优化"></a>3.3 子查询优化</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#不推荐</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp a <span class="keyword">WHERE</span> a.id <span class="keyword">NOT</span> <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> b.ceo <span class="keyword">FROM</span> t_dept b <span class="keyword">WHERE</span> b.ceo <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>);</span><br><span class="line">#推荐</span><br><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span> <span class="keyword">FROM</span> t_emp a </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_dept b </span><br><span class="line"><span class="keyword">ON</span> a.id <span class="operator">=</span> b.ceo </span><br><span class="line"><span class="keyword">WHERE</span> b.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><h2 id="3-4-排序优化"><a href="#3-4-排序优化" class="headerlink" title="3.4 排序优化"></a>3.4 排序优化</h2><h3 id="3-4-1-排序优化"><a href="#3-4-1-排序优化" class="headerlink" title="3.4.1 排序优化"></a>3.4.1 排序优化</h3><p><strong>order by时不限制索引失效</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#创建索引  </span><br><span class="line"><span class="keyword">CREATE</span>  INDEX idx_age_deptid_name <span class="keyword">ON</span> emp (age,deptid,NAME)</span><br><span class="line">#不限制,索引失效</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span>  <span class="keyword">BY</span> age,deptid;   </span><br><span class="line">#增加limit过滤条件，使用上索引了。（全局数据太大索引作用不大，分页只查询小数据索引不失效）</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span>  <span class="keyword">BY</span> age,deptid LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>order by时顺序错误,索引失效</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建索引age,deptid,NAME</span><br><span class="line"><span class="keyword">CREATE</span>  INDEX idx_age_deptid_name <span class="keyword">ON</span> emp (age,deptid,NAME)</span><br><span class="line">#创建索引age,deptid,empno</span><br><span class="line"><span class="keyword">CREATE</span>  INDEX idx_age_deptid_empno <span class="keyword">ON</span> emp (age,deptid,empno); </span><br><span class="line">#以下哪些索引失效?</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> deptid;  </span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> deptid,NAME;   </span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> deptid,empno;  </span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME,deptid;  </span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptid<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age;  </span><br></pre></td></tr></table></figure><p><strong>order by时规则不一致, 索引失效</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> deptid <span class="keyword">DESC</span>, NAME <span class="keyword">DESC</span> ;  </span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> deptid <span class="keyword">ASC</span>, NAME <span class="keyword">DESC</span> ;      </span><br></pre></td></tr></table></figure><h3 id="3-4-2-案例实战"><a href="#3-4-2-案例实战" class="headerlink" title="3.4.2 案例实战"></a>3.4.2 案例实战</h3><p>执行案例前先清除emp上的索引，只留主键</p><p><strong>场景:查询年龄为30岁的，且员工编号小于101000的用户，按用户名称排序</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age <span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> empno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME ; </span><br></pre></td></tr></table></figure><p>type 是 ALL，即最坏的情况。Extra 里还出现了 Using filesort,也是最坏的情况。</p><p>优化思路：</p><p><strong>方案一: 尽量让where的过滤条件和排序使用上索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_empno_name <span class="keyword">ON</span> emp (age,empno,NAME);</span><br></pre></td></tr></table></figure><p><strong>方案二: 为了去掉filesort我们可以把索引建成</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#删除旧索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_age_empno_name <span class="keyword">ON</span> emp</span><br><span class="line">#创建新索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> emp(age,NAME);</span><br></pre></td></tr></table></figure><p>empno 和name这个两个字段二选其一, 优化掉了 using filesort。</p><p><strong>方案三: 选择范围过滤，放弃排序上的索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#删除旧索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_age_name <span class="keyword">ON</span> emp;</span><br><span class="line">#创建新索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_empno <span class="keyword">ON</span> emp(age,empno);</span><br></pre></td></tr></table></figure><p> <strong>结论: filesort，而且type为range, 但是效率更高了,为什么?</strong> </p><p>原因：</p><ul><li>两个索引同时存在，mysql自动选择最优的方案：（对于这个例子，mysql选择idx_age_empno），但是，随着数据量的变化，选择的索引也会随之变化的</li><li>所有的排序都是在条件过滤之后才执行的，所以，如果条件过滤掉大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。 相对的 empno&lt;101000 这个条件，如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。</li></ul><p> <strong>小结(重点):</strong> </p><p><strong>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</strong></p><h3 id="3-4-3-双路排序和单路排序"><a href="#3-4-3-双路排序和单路排序" class="headerlink" title="3.4.3 双路排序和单路排序"></a>3.4.3 双路排序和单路排序</h3><p>排序的字段若如果不在索引列上，则filesort会有两种算法<strong>双路排序</strong>和<strong>单路排序</strong></p><p><strong>双路排序</strong></p><p>MySQL 4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和order by列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出, 从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。取一批数据，要对磁盘进行两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</p><p><strong>单路排序</strong></p><p>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</p><p><strong>单路排序存在的问题</strong></p><p>在sort_buffer中，单路比多路要多占用很多空间，因为单路是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排……从而多次I/O。单路本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。优化策略如下:</p><ul><li><p>增大sort_buffer_size参数的设置</p></li><li><p>增大max_length_for_sort_data参数的设置</p></li><li><p>减少select 后面的查询的字段。</p></li></ul><h3 id="3-4-4-Order-By效率优化"><a href="#3-4-4-Order-By效率优化" class="headerlink" title="3.4.4 Order By效率优化"></a>3.4.4 Order By效率优化</h3><ol><li><p>Order by时select * 是一个大忌</p><ul><li>当Query的字段大小总和小于max_length_for_sort_data 而且排序字段不是TEXT|BLOB 类型时，会用单路排序，否则用多路排序</li><li>两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size</li></ul></li><li><p>尝试提高 sort_buffer_size</p><ul><li>不管用哪种算法，提高这个参数都会提高效率，要根据系统的能力去提高，因为这个参数是针对每个进程（connection）的 1M-8M之间调整。 MySQL5.7，InnoDB存储引擎默认值是1048576字节，1MB。</li></ul></li><li><p>尝试提高 max_length_for_sort_data</p><ul><li>提高这个参数， 会增加用改进算法的概率。</li><li>但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。如果需要返回的列的总长度大于max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192字节之间调整</li></ul></li></ol><h3 id="3-4-5-GROUP-BY优化"><a href="#3-4-5-GROUP-BY优化" class="headerlink" title="3.4.5 GROUP BY优化"></a>3.4.5 GROUP BY优化</h3><p>group by 使用索引的原则几乎跟order by一致 ，唯一区别：</p><ul><li><p>group by 先排序再分组，遵照索引建的最佳左前缀法则</p></li><li><p>当无法使用索引列，增大max_length_for_sort_data和sort_buffer_size参数的设置</p></li><li><p>where高于having, 能写在where限定的条件就不要写在having中了</p></li></ul><h2 id="3-5-覆盖索引"><a href="#3-5-覆盖索引" class="headerlink" title="3.5 覆盖索引"></a>3.5 覆盖索引</h2><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。** 一个索引包含了满足查询结果的数据就叫做覆盖索引 **</p><p><strong>理解方式二</strong>：非聚集复合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段，也即，索引包含了查询正在查找的数据）。</p><h1 id="4-慢查询日志"><a href="#4-慢查询日志" class="headerlink" title="4 慢查询日志"></a>4 慢查询日志</h1><h2 id="4-1-慢查询日志介绍"><a href="#4-1-慢查询日志介绍" class="headerlink" title="4.1 慢查询日志介绍"></a>4.1 慢查询日志介绍</h2><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。 long_query_time的默认值为10，意思是运行10秒以上的语句。 由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。</p><p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。</p><p><strong>如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。</strong></p><h2 id="4-2-查看及开启"><a href="#4-2-查看及开启" class="headerlink" title="4.2 查看及开启"></a>4.2 查看及开启</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#默认情况下slow_query_log的值为OFF</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_query_log%&#x27;</span>;  </span><br></pre></td></tr></table></figure><p>命令行开启：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure><p>慢查询日志记录long_query_time时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;long_query_time&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time<span class="operator">=</span><span class="number">0.1</span>; </span><br></pre></td></tr></table></figure><p><strong>注意: 运行时间正好等于long_query_time的情况，并不会被记录下来。</strong></p><p>永久生效</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">修改my.cnf文件，[mysqld]下增加或修改参数slow_query_log</span> <span class="string">和slow_query_log_file后，然后重启MySQL服务器。也即将如下两行配置进my.cnf文件 </span></span><br><span class="line"><span class="attr">slow_query_log</span> =<span class="string">1</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=<span class="string">/var/lib/mysql/atguigu-slow.log </span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">log_output</span>=<span class="string">FILE</span></span><br></pre></td></tr></table></figure><p>查询当前系统中有多少条慢查询记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>; </span><br></pre></td></tr></table></figure><h2 id="4-3-mysqldumpslow"><a href="#4-3-mysqldumpslow" class="headerlink" title="4.3 mysqldumpslow"></a>4.3 mysqldumpslow</h2><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。 </p><p>-a: 不将数字抽象成N，字符串抽象成S</p><p>-s: 是表示按照何种方式排序；</p><p> c: 访问次数</p><p> l: 锁定时间</p><p> r: 返回记录</p><p> t: 查询时间</p><p> al:平均锁定时间</p><p> ar:平均返回记录数</p><p> at:平均查询时间</p><p>-t: 即为返回前面多少条的数据；</p><p>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#得到返回记录集最多的<span class="number">10</span>个<span class="keyword">SQL</span></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu<span class="operator">-</span>slow.log</span><br><span class="line">#得到访问次数最多的<span class="number">10</span>个<span class="keyword">SQL</span></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s c <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu<span class="operator">-</span>slow.log</span><br><span class="line">#得到按照时间排序的前<span class="number">10</span>条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">10</span> <span class="operator">-</span>g &quot;left join&quot; <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu<span class="operator">-</span>slow.log</span><br><span class="line">#另外建议在使用这些命令时结合 <span class="operator">|</span> 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu<span class="operator">-</span>slow.log <span class="operator">|</span> more</span><br></pre></td></tr></table></figure><h1 id="5-View视图"><a href="#5-View视图" class="headerlink" title="5 View视图"></a>5 View视图</h1><p>视图是将一段查询sql封装为一个虚拟的表。 这个虚拟表只保存了sql逻辑，不会保存任何查询结果。</p><p><strong>主要作用:</strong></p><ul><li>封装复杂sql语句，提高复用性</li><li>逻辑放在数据库上面，更新不需要发布程序，面对频繁的需求变更更灵活</li></ul><p><strong>常用场景:</strong></p><ul><li>共用查询结果</li><li>报表</li></ul><p><strong>语法:</strong></p><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> <span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name  <span class="keyword">WHERE</span> <span class="keyword">condition</span>  </span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查询</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> view_name </span><br><span class="line">#更新</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> view_name </span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL高级&quot;&gt;&lt;a href=&quot;#MySQL高级&quot; class=&quot;headerlink&quot; title=&quot;MySQL高级&quot;&gt;&lt;/a&gt;MySQL高级&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MySQL的索引（理论）&lt;/li&gt;
&lt;li&gt;如何让索引生效？（理论）—&amp;gt;这个索引生</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="SQL优化" scheme="http://example.com/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
    <category term="Explain" scheme="http://example.com/tags/Explain/"/>
    
    <category term="索引失效" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"/>
    
    <category term="慢查询日志" scheme="http://example.com/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/"/>
    
    <category term="View视图" scheme="http://example.com/tags/View%E8%A7%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://example.com/2022/12/02/MySQL/"/>
    <id>http://example.com/2022/12/02/MySQL/</id>
    <published>2022-12-02T15:39:17.000Z</published>
    <updated>2022-12-04T08:14:17.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ul><li><strong>mysql逻辑架构(理论)</strong></li><li><strong>索引(数据结构): mysql为什么要使用b+树</strong></li><li><strong>存储引擎: 5种</strong></li><li><strong>join查询</strong></li></ul><h1 id="1-逻辑架构"><a href="#1-逻辑架构" class="headerlink" title="1 逻辑架构"></a>1 逻辑架构</h1><h2 id="1-1-架构概览"><a href="#1-1-架构概览" class="headerlink" title="1.1 架构概览"></a>1.1 架构概览</h2><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。</p><p>这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 </p><p><img src="/2022/12/02/MySQL/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="逻辑架构图"></p><p>简单理解即为：</p><p><img src="/2022/12/02/MySQL/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png"></p><h3 id="1-1-1-连接层"><a href="#1-1-1-连接层" class="headerlink" title="1.1.1 连接层"></a>1.1.1 连接层</h3><p>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。</p><p>主要完成一些类似于连接处理、授权认证、及相关的安全方案。</p><p>在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。</p><p>同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 </p><h3 id="1-1-2-服务层"><a href="#1-1-2-服务层" class="headerlink" title="1.1.2 服务层"></a>1.1.2 服务层</h3><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。</p><p>所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p><p>在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。</p><p>如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><p>2.1 Management Serveices &amp; Utilities： 系统管理和控制工具 </p><p>2.2 SQL Interface: SQL接口</p><ul><li>接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</li></ul><p>2.3 Parser: 解析器</p><ul><li>SQL命令传递到解析器的时候会被解析器验证和解析。 </li></ul><p>2.4 Optimizer: 查询优化器。（索引命中）</p><ul><li>SQL语句在查询之前会使用查询优化器对查询进行优化。 </li><li>用一个例子就可以理解： select uid,name from user where gender= 1;</li><li>优化器来决定先投影还是先过滤。 </li></ul><p>2.5 Cache和Buffer： 查询缓存。</p><ul><li>如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 </li></ul><h3 id="1-1-3-引擎层"><a href="#1-1-3-引擎层" class="headerlink" title="1.1.3 引擎层"></a>1.1.3 引擎层</h3><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB </p><h3 id="1-1-4-存储层"><a href="#1-1-4-存储层" class="headerlink" title="1.1.4 存储层"></a>1.1.4 存储层</h3><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。 </p><h2 id="1-2-show-profiles"><a href="#1-2-show-profiles" class="headerlink" title="1.2 show profiles"></a>1.2 show profiles</h2><p>了解查询语句底层执行的过程：select @@profiling;查看是否开启计划。</p><ol><li>  修改配置文件/etc/my.cnf，先开启查询缓存</li></ol><p>新增一行：query_cache_type=1</p><p>重启mysql：systemctl restart mysqld</p><ol start="2"><li>  再开启查询执行计划</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%profiling%&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure><ol start="3"><li>  执行语句两次：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mydb.mytbl <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure><ol start="4"><li>  显示最近执行的语句</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profiles; </span><br></pre></td></tr></table></figure><p><img src="/2022/12/02/MySQL/image-20210602092918061.png" alt="image-20210602092918061"></p><ol start="5"><li>  显示执行计划</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile cpu,block io <span class="keyword">for</span> query <span class="number">6</span>; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/02/MySQL/image-20210602092929003.png" alt="image-20210602092929003"></p><p><img src="/2022/12/02/MySQL/image-20210602092950982.png" alt="image-20210602092950982"></p><p>执行编号7时，比执行编号6时少了很多信息，从下面截图中可以看出查询语句直接从缓存中获取数据；</p><p>==<strong>注意：SQL必须是一致的，否则，不能命中缓存。</strong>==</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#虽然查询结果一致，但并没有命中缓存。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mydb.mytbl <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mydb.mytbl <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">1</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="1-3-工作流程"><a href="#1-3-工作流程" class="headerlink" title="1.3 工作流程"></a>1.3 工作流程</h2><p>==<strong>mysql的查询流程：</strong>==</p><ol><li>首先，mysql客户端通过协议与mysql服务器建连接，发送查询语句，先检查查询缓存，如果命中，直接返回结果，否则进行语句解析，也就是说，在解析查询之前，服务器会先访问查询缓存(query cache)——它存储SELECT语句以及相应的查询结果集。</li><li>如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。</li><li>语法解析器和预处理：首先mysql通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”。</li><li>mysql解析器将使用mysql语法规则验证和解析查询；</li><li>预处理器则根据一些mysql规则进一步检查解析树是否合法。 </li><li>查询优化器当解析树被认为是合法的了，并且由优化器将其转化成执行计划。</li><li>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。 </li><li>mysql默认使用的BTREE索引，并且一个大致方向是：无论怎么折腾sql，至少在目前来说，mysql最多只用到表中的一个索引。</li></ol><h1 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2 存储引擎"></a>2 存储引擎</h1><h2 id="2-1-查看存储引擎"><a href="#2-1-查看存储引擎" class="headerlink" title="2.1 查看存储引擎"></a>2.1 查看存储引擎</h2><p>查看mysql提供什么存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/02/MySQL/image-20210602093145257.png" alt="image-20210602093145257"></p><p>查看默认的存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>; </span><br></pre></td></tr></table></figure><p><img src="/2022/12/02/MySQL/image-20210602093209298.png" alt="image-20210602093209298"></p><h2 id="2-2-引擎介绍"><a href="#2-2-引擎介绍" class="headerlink" title="2.2 引擎介绍"></a>2.2 引擎介绍</h2><h3 id="2-2-1-InnoDB"><a href="#2-2-1-InnoDB" class="headerlink" title="2.2.1 InnoDB"></a>2.2.1 InnoDB</h3><ul><li><strong>大于等于5.5之后，默认采用InnoDB引擎</strong>。</li><li>InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li><li>除了增加和查询外，还需要更新，删除操作，那么，应优选选择InnoDB存储引擎。</li><li>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</li></ul><h3 id="2-2-2-MyISAM"><a href="#2-2-2-MyISAM" class="headerlink" title="2.2.2 MyISAM"></a>2.2.2 MyISAM</h3><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务和行级锁，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</li><li>5.5之前默认的存储引擎</li><li>数据文件结构：<ul><li>.frm 存储定义表</li><li>.MYD 存储数据</li><li>.MYI 存储索引</li></ul></li></ul><p>==<strong>特别注意：</strong>==</p><ul><li>静态表字段都是非变长字段，存储占用空间比动态表多。存储数据时会按照列宽补足空格，但在访问时候并不会得到这些空格。</li><li>如果存储数据本身后面有空格，那么，查询时也会被去掉。</li><li>如果存储数据本身前面有空格，则查询时不会被去掉。</li><li>在没有where条件情况下统计表count(*)数量，不需要全表扫描，而是直接获取保存好的值。</li></ul><h3 id="2-2-3-Archive"><a href="#2-2-3-Archive" class="headerlink" title="2.2.3 Archive"></a>2.2.3 Archive</h3><ul><li>Archive档案存储引擎只支持<strong>INSERT</strong>和<strong>SELECT</strong>操作，在MySQL5.1之前不支持索引。</li><li>Archive表<strong>适合日志和数据采集（档案）</strong>类应用。</li><li>根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。</li></ul><h3 id="2-2-4-Blackhole"><a href="#2-2-4-Blackhole" class="headerlink" title="2.2.4 Blackhole"></a>2.2.4 Blackhole</h3><ul><li>Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。</li><li>但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。</li></ul><h3 id="2-2-5-CSV"><a href="#2-2-5-CSV" class="headerlink" title="2.2.5 CSV"></a>2.2.5 CSV</h3><ul><li>CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。</li><li>CSV引擎可以作为一种数据交换的机制，非常有用。</li><li>CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。</li></ul><h3 id="2-2-6-Memory引擎"><a href="#2-2-6-Memory引擎" class="headerlink" title="2.2.6 Memory引擎"></a>2.2.6 Memory引擎</h3><ul><li>如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。</li><li>Memory表至少比MyISAM表要快一个数量级。</li></ul><h3 id="2-2-7-Federated引擎"><a href="#2-2-7-Federated引擎" class="headerlink" title="2.2.7 Federated引擎"></a>2.2.7 Federated引擎</h3><ul><li>Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li></ul><h2 id="2-3-MyISAM和InnoDB"><a href="#2-3-MyISAM和InnoDB" class="headerlink" title="2.3 MyISAM和InnoDB"></a>2.3 MyISAM和InnoDB</h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr><tr><td>关注点</td><td>性能：节省资源、消耗少、简单业务</td><td>事务：并发写、事务、更大资源</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr></tbody></table><h1 id="3-索引入门"><a href="#3-索引入门" class="headerlink" title="3 索引入门"></a>3 索引入门</h1><h2 id="3-1-索引简介"><a href="#3-1-索引简介" class="headerlink" title="3.1 索引简介"></a>3.1 索引简介</h2><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL<strong>高效获取数据的数据结构</strong>。 </p><p>索引的本质：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”。</p><p>下图就是一种可能的索引方式示例：</p><p><img src="/2022/12/02/MySQL/image-20210602100619962.png" alt="image-20210602100619962">  </p><p><strong>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址</strong></p><p>为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</p><p>数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是<strong>索引</strong>。</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往<strong>以索引文件形式存储磁盘上</strong></p><h2 id="3-2-优点与缺点"><a href="#3-2-优点与缺点" class="headerlink" title="3.2 优点与缺点"></a>3.2 优点与缺点</h2><p>优点:</p><ul><li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li></ul><p>缺点:</p><ul><li><p>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以<strong>索引列也是要占用空间</strong>的</p></li><li><p>虽然索引大大提高了查询速度，同时却会<strong>降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。 因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</p></li></ul><h2 id="3-3-索引结构"><a href="#3-3-索引结构" class="headerlink" title="3.3 索引结构"></a>3.3 索引结构</h2><h3 id="3-3-1-Hash"><a href="#3-3-1-Hash" class="headerlink" title="3.3.1 Hash"></a>3.3.1 Hash</h3><p>加速查找速度的数据结构，常见的有两类：</p><p>(1)哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是O(1)；</p><p>哈希索引：</p><p><img src="/2022/12/02/MySQL/%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95-1670137812737.png"></p><p>(2)树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是O(log2N)；</p><p>可以看到，不管是读请求，还是写请求，哈希类型的索引，都要比树型的索引更快一些，</p><p><strong>那为什么，索引结构要设计成树型呢？</strong></p><p>想想<strong>范围/排序</strong>等其它SQL条件：</p><p>哈希型的索引，时间复杂度会退化为O(n)而<strong>树型的“有序”特性</strong>，依然能够保持O(log2N) 的高效率。</p><p>备注：InnoDB并不支持哈希索引。</p><h3 id="3-3-2-时间复杂度"><a href="#3-3-2-时间复杂度" class="headerlink" title="3.3.2 时间复杂度"></a>3.3.2 时间复杂度</h3><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。</p><p><img src="/2022/12/02/MySQL/image-20210602100853184.png" alt="image-20210602100853184"></p><p><img src="/2022/12/02/MySQL/image-20210602100858992.png" alt="image-20210602100858992"></p><h3 id="3-3-3-普通二叉树"><a href="#3-3-3-普通二叉树" class="headerlink" title="3.3.3 普通二叉树"></a>3.3.3 普通二叉树</h3><p>二叉树的特点：</p><ul><li>一个节点只能有两个子节点，也就是一个节点度不能超过2</li><li>左子节点 小于 本节点；右子节点大于等于 本节点，比我大的向右，比我小的向左</li></ul><p><img src="/2022/12/02/MySQL/image-20210602100943179.png" alt="image-20210602100943179"></p><p>对该二叉树的节点进行查找</p><ul><li><p>深度为1的节点的查找次数为1，</p></li><li><p>深度为2的节点的查找次数为2，</p></li><li><p>深度为N的节点的查找次数为N，</p></li></ul><p>结论：因此其平均查找次数为 (1+2+2+3+3+3) / 6 = 2.3次</p><blockquote><p>每次查找数据可以字节丢弃50%的数据进行查找，提高查找效率</p></blockquote><h3 id="3-3-4-平衡二叉树"><a href="#3-3-4-平衡二叉树" class="headerlink" title="3.3.4 平衡二叉树"></a>3.3.4 平衡二叉树</h3><p><strong>平衡二叉树</strong>（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：</p><p><strong>==它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。==</strong></p><p><code>这个方案很好的解决了二叉查找树退化成链表的问题</code>，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。</p><p><img src="/2022/12/02/MySQL/image-20210602101040214.png" alt="image-20210602101040214"></p><p>平衡二叉树大部分操作和二叉查找树类似，主要不同在于插入删除的时候平衡二叉树的平衡可能被改变，并且只有从那些插入点到根结点的路径上的结点的平衡性可能被改变，因为只有这些结点的子树可能变化。</p><h3 id="3-3-5-BTree-重点"><a href="#3-3-5-BTree-重点" class="headerlink" title="3.3.5 BTree(重点)"></a>3.3.5 BTree(重点)</h3><p><strong>B-Tree树即</strong>B树，B即Balanced，平衡的意思。</p><p><strong>B树的阶：</strong>节点的最多子节点个数。</p><p>B树的搜索，从根结点开始，对节点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点；重复，直到所对应的儿子指针为空，或已经是叶子节点, 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据, 搜索有可能在非叶子节点结束,其搜索性能等价于在关键字全集内做一次二分查找</p><p><img src="/2022/12/02/MySQL/image-20210602101333676.png" alt="image-20210602101333676"></p><p><strong>那么，我们思考一个问题，索引树会一次性加载吗？</strong></p><ul><li><code>数据库索引是存储在磁盘上的，如果数据很大，必然导致索引的大小也会很大，超过几个G</code>（好比新华字典字数多必然导致目录厚</li><li>当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：</li><li>逐一加载每一个<strong>磁盘页</strong>，因为磁盘页对应着索引树的节点。</li></ul><p> <img src="/2022/12/02/MySQL/image-20210602101455325.png" alt="image-20210602101455325"></p><p><strong>页</strong></p><p>Page是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在Page结构里。</p><p>Page分为几种类型：<strong>数据页（B-Tree Node），Undo页（Undo Log Page），系统页（System Page），事务数据页（Transaction System Page）</strong>等；**==每个数据页的大小为16kb==**，每个Page使用一个32位（一位表示的就是0或1）的int值来表示，正好对应Innodb最大64TB的存储容量(16kb * 2^32=64tib)</p><p><img src="/2022/12/02/MySQL/image-20210602101656506.png" alt="image-20210602101656506"></p><p><strong>块</strong></p><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB存储引擎中有页（Page）的概念，系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p><p>==<strong>Btree的查询流程</strong>==</p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。</p><p>模拟查找关键字29的过程：</p><ul><li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li><li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li><li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li><li>在磁盘块8中的关键字列表中找到关键字29。</li></ul><p>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个BTree查找效率的决定因素。</p><p><strong>BTree相对于AVLTree每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</strong></p><h3 id="3-3-6-B-Tree-重点"><a href="#3-3-6-B-Tree-重点" class="headerlink" title="3.3.6 B+Tree(重点)"></a>3.3.6 B+Tree(重点)</h3><p>  B+树是B树的变体，也是一种多路搜索树。B+树的搜索与B树也基本相同，区别是B+树只有达到叶子节点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</p><p>**==所有关键字都出现在叶子节点的链表中（即数据只能在叶子节点）==**，且链表中的关键字(数据)恰好是有序的。因此不可能在非叶子节点命中, <strong>==非叶子节点相当于是叶子节点的索引，叶子节点相当于是存储（关键字）数据的数据层==</strong></p><p><img src="/2022/12/02/MySQL/image-20210602102758064.png" alt="image-20210602102758064"></p><p>通常在 B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。 因此可以对 B+Tree 进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。 </p><p>InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用 4 个字节）或 BIGINT（占用 8 个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 16KB/(8B+8B)=1K 个键值（因为是估值，为方便计算，这里的 K 取值为 10^3。也就是说一个深度为 3 的 B+Tree 索引可以维护 10^3 _ 10^3 _ 10^3 = 10 亿条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2<del>4 层。MySQL 的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1</del>3 次磁盘 I/O 操作。</p><p>==<strong>BTree和B+Tree比较</strong>==</p><ul><li><strong>B</strong>树结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B树的深度较大，增大查询时的磁盘I/O次数进而影响查询效率。</li><li><strong>B+树</strong>中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+树的高度。</li></ul><h2 id="3-4-聚簇与非聚簇索引-重点"><a href="#3-4-聚簇与非聚簇索引-重点" class="headerlink" title="3.4 聚簇与非聚簇索引(重点)"></a>3.4 聚簇与非聚簇索引(重点)</h2><h3 id="3-4-1-聚簇索引"><a href="#3-4-1-聚簇索引" class="headerlink" title="3.4.1 聚簇索引"></a>3.4.1 聚簇索引</h3><p><strong>聚簇索引</strong>并不是一种单独的索引类型，而<strong>是一种数据存储方式</strong>。聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。</p><p>Innodb通过主键聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引。</p><p><strong>优点：</strong></p><ul><li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快</li></ul><p><strong>缺点：</strong></p><ul><li>插入速度严重依赖于插入顺序，按照主键的<strong>顺序插入</strong>是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列为主键</strong></li><li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</li></ul><h3 id="3-4-2-非聚簇索引"><a href="#3-4-2-非聚簇索引" class="headerlink" title="3.4.2 非聚簇索引"></a>3.4.2 非聚簇索引</h3><p>在<strong>聚簇索引之上创建的索引称之为非聚簇索引</strong>，非聚簇索引访问数据总是需要二次查找。非聚簇索引叶子节点存储的不再是行的物理位置，而是主键值。通过非聚簇索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。</p><p>Innodb非聚簇索引的叶子节点并<strong>不包含行记录的全部数据</strong>，叶子节点除了包含键值外，还包含了相应行数据的聚簇索引键。</p><p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。在innodb中有时也称非聚簇索引为二级索引或辅助索引。</p><h2 id="3-5-小结-笔记"><a href="#3-5-小结-笔记" class="headerlink" title="3.5 小结(笔记)"></a>3.5 小结(笔记)</h2><ul><li>数据库索引用于加速查询</li><li>虽然哈希索引是 O(1)，树索引是 O(log(n))，但 SQL 有很多“有序”需求，故数据库使用树型索引</li><li>InnoDB 不支持哈希索引</li><li>数据预读的思路是：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘 IO</li><li>数据库的索引最常用 B+树： <ul><li>很适合磁盘存储，能够充分利用局部性原理，磁盘预读； </li><li>很低的树高度，能够存储大量数据；</li><li>索引本身占用的内存很小；</li><li>能够很好的支持单点查询，范围查询，有序性查询；</li></ul></li></ul><h1 id="4-MySQL索引"><a href="#4-MySQL索引" class="headerlink" title="4 MySQL索引"></a>4 MySQL索引</h1><h2 id="4-1-单值索引"><a href="#4-1-单值索引" class="headerlink" title="4.1 单值索引"></a>4.1 单值索引</h2><p>即一个索引只包含单个列，一个表可以有多个单列索引，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">随表一起建索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">  KEY (customer_name)</span><br><span class="line">);</span><br><span class="line">单独建单值索引：</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_customer_name <span class="keyword">ON</span> customer(customer_name); </span><br><span class="line">删除索引：</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_customer_name  <span class="keyword">on</span> customer;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-2-唯一索引"><a href="#4-2-唯一索引" class="headerlink" title="4.2 唯一索引"></a>4.2 唯一索引</h2><p>索引列的值必须唯一，但允许有空值，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">随表一起建索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">  KEY (customer_name),</span><br><span class="line">  <span class="keyword">UNIQUE</span> (customer_no)</span><br><span class="line">);</span><br><span class="line">单独建唯一索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_customer_no <span class="keyword">ON</span> customer(customer_no); </span><br><span class="line">删除索引：</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_customer_no <span class="keyword">on</span> customer ;</span><br></pre></td></tr></table></figure><h2 id="4-3-主键索引"><a href="#4-3-主键索引" class="headerlink" title="4.3 主键索引"></a>4.3 主键索引</h2><p>设定为主键后数据库会自动建立索引（不能有null），<strong>innodb</strong>为聚簇索引，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">随表一起建索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer2 (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED   ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>) </span><br><span class="line">);</span><br><span class="line">单独建主键索引：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customer2 <span class="keyword">add</span> <span class="keyword">PRIMARY</span> KEY customer2(id);  </span><br><span class="line">删除主键索引：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customer2 <span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY ;  </span><br><span class="line">修改主键索引：</span><br><span class="line">必须先删除掉(<span class="keyword">drop</span>)原索引，再新建(<span class="keyword">add</span>)索引</span><br></pre></td></tr></table></figure><h2 id="4-4-复合索引"><a href="#4-4-复合索引" class="headerlink" title="4.4 复合索引"></a>4.4 复合索引</h2><p>即一个索引包含多个列，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 随表一起建索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">  KEY (customer_name),</span><br><span class="line">  <span class="keyword">UNIQUE</span> (customer_name),</span><br><span class="line">  KEY (customer_no,customer_name)</span><br><span class="line">);</span><br><span class="line">单独建索引：</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_customer_no_name <span class="keyword">ON</span> customer(customer_no,customer_name); </span><br><span class="line">删除索引：</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_customer_no_name  <span class="keyword">on</span> customer ;</span><br></pre></td></tr></table></figure><h2 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5 小结"></a>4.5 小结</h2><p>==<strong>哪些情况需要创建索引</strong>==</p><ul><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题，who？(在高并发下倾向创建组合索引)</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ul><p><strong>==哪些情况不要创建索引==</strong></p><ul><li><p>表记录太少，300万数据时MySQL性能就开始下降了，这时就可以开始开始优化了</p></li><li><p>经常增删改的表，提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件</p></li><li><p>where条件里用不到的字段</p></li><li><p>数据重复过滤性不好的字段</p></li></ul><h1 id="5-SQL优化-重点"><a href="#5-SQL优化-重点" class="headerlink" title="5 SQL优化(重点)"></a>5 SQL优化(重点)</h1><h2 id="5-1-SQL执行顺序"><a href="#5-1-SQL执行顺序" class="headerlink" title="5.1 SQL执行顺序"></a>5.1 SQL执行顺序</h2><p><img src="/2022/12/02/MySQL/image-20210602104459899.png" alt="image-20210602104459899"></p><p>从这个顺序中我们不难发现，所有的查询语句都是从from开始执行的，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。<br><strong>第一步：</strong>首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 <strong>vt1</strong>（选择相对小的表做基础表） </p><p><strong>第二步：</strong>接下来便是应用on筛选器，on中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 <strong>vt2</strong> </p><p><strong>第三步：</strong>如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 <strong>vt3</strong> </p><p><strong>第四步：</strong>如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3</p><p><strong>第五步：</strong>应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表<strong>vt4</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">注意</span>:<span class="string">对于包含outer join子句的查询，到底在on筛选器还是用where筛选器指定逻辑表达式呢？</span></span><br><span class="line"><span class="attr">on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer</span> <span class="string">join中还可以把移除的行再次添加回来，而where的移除的最终的。</span></span><br><span class="line"><span class="attr">举个简单的例子</span>:<span class="string"></span></span><br><span class="line"><span class="attr">有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。</span></span><br><span class="line"><span class="attr">为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名</span>=<span class="string">成绩.姓名）</span></span><br><span class="line"><span class="attr">那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了</span></span><br><span class="line"><span class="attr">但是我们用left</span> <span class="string">outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生</span></span><br><span class="line"><span class="attr">如果在on中应用学生.班级</span>=<span class="string">&#x27;x&#x27;的话，left outer join会把x班级的所有学生记录找回</span></span><br><span class="line"><span class="attr">所以只能在where筛选器中应用学生.班级</span>=<span class="string">&#x27;x&#x27; 因为它的过滤是最终的。 </span></span><br><span class="line"><span class="attr">总结</span>: <span class="string">最终过滤条件放在where语句中,on语句做数据匹配不要做筛选!!!</span></span><br></pre></td></tr></table></figure><p><strong>第六步：</strong>group by 子句将中的唯一的值组合成为一组，得到虚拟表<strong>vt5</strong>。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。==原因在于最终的结果集中只为每个组包含一行,这一点请牢记。== </p><p><strong>第七步：</strong>应用cube或者rollup选项，为vt5生成超组，生成<strong>vt6</strong></p><p>[^ROLLUP]: 是GROUP BY子句的一种扩展，可以为每个分组返回小计记录以及为所有分组返回总计记录。<br>[^CUBE]: 也是GROUP BY子句的一种扩展，可以返回每一个列组合的小计记录，同时在末尾加上总计记录。</p><p><strong>第八步：</strong>应用having筛选器，生成<strong>vt7</strong>。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器</p><p><strong>第九步：</strong>处理select子句。将vt7中的在select中出现的列筛选出来。生成<strong>vt8</strong></p><p><strong>第十步：</strong>应用distinct子句，vt8中移除相同的行，生成<strong>vt9</strong></p><p>[^注意]: ==如果应用了group by子句那么distinct是多余的，原因同样在于分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的==</p><p><strong>第十一步：</strong>应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表</p><p>[^游标]: sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。</p><p><strong>第十二步：</strong>返回结果给请求者即用户 </p><h2 id="5-2-测试数据"><a href="#5-2-测试数据" class="headerlink" title="5.2 测试数据"></a>5.2 测试数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_dept` (</span><br><span class="line"> `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `deptName` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `address` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_emp` (</span><br><span class="line"> `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `deptId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`empno` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"> KEY `idx_dept_id` (`deptId`)</span><br><span class="line"> #<span class="keyword">CONSTRAINT</span> `fk_dept_id` <span class="keyword">FOREIGN</span> KEY (`deptId`) <span class="keyword">REFERENCES</span> `t_dept` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;华山&#x27;</span>,<span class="string">&#x27;华山&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;丐帮&#x27;</span>,<span class="string">&#x27;洛阳&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;峨眉&#x27;</span>,<span class="string">&#x27;峨眉山&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">&#x27;武当&#x27;</span>,<span class="string">&#x27;武当山&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">&#x27;明教&#x27;</span>,<span class="string">&#x27;光明顶&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">&#x27;少林&#x27;</span>,<span class="string">&#x27;少林寺&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;风清扬&#x27;</span>,<span class="number">90</span>,<span class="number">1</span>,<span class="number">100001</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;岳不群&#x27;</span>,<span class="number">50</span>,<span class="number">1</span>,<span class="number">100002</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;令狐冲&#x27;</span>,<span class="number">24</span>,<span class="number">1</span>,<span class="number">100003</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">&#x27;洪七公&#x27;</span>,<span class="number">70</span>,<span class="number">2</span>,<span class="number">100004</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">&#x27;乔峰&#x27;</span>,<span class="number">35</span>,<span class="number">2</span>,<span class="number">100005</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">&#x27;灭绝师太&#x27;</span>,<span class="number">70</span>,<span class="number">3</span>,<span class="number">100006</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">7</span>,<span class="string">&#x27;周芷若&#x27;</span>,<span class="number">20</span>,<span class="number">3</span>,<span class="number">100007</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">8</span>,<span class="string">&#x27;张三丰&#x27;</span>,<span class="number">100</span>,<span class="number">4</span>,<span class="number">100008</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">9</span>,<span class="string">&#x27;张无忌&#x27;</span>,<span class="number">25</span>,<span class="number">5</span>,<span class="number">100009</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">10</span>,<span class="string">&#x27;韦小宝&#x27;</span>,<span class="number">18</span>,<span class="keyword">NULL</span>,<span class="number">100010</span>);</span><br></pre></td></tr></table></figure><h2 id="5-3-JOIN查询"><a href="#5-3-JOIN查询" class="headerlink" title="5.3 JOIN查询"></a>5.3 JOIN查询</h2><h3 id="5-3-1-join查询入门"><a href="#5-3-1-join查询入门" class="headerlink" title="5.3.1 join查询入门"></a>5.3.1 join查询入门</h3><p><strong>场景1: A、B两表共有(查询所有有部门的员工-&gt;员工和部门之间必须存在关联的数据)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">inner</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br></pre></td></tr></table></figure><p><strong>场景2:  A、B两表共有+A的独有（列出所有用户，并显示其机构信息）A的全集</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">left</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br></pre></td></tr></table></figure><p><strong>场景3: A、B两表共有+B的独有（列出所有部门，并显示其部门的员工信息 ）B的全集</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">right</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br></pre></td></tr></table></figure><p><strong>场景4: A的独有 （查询没有加入任何部门的员工）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">left</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">where</span> t_emp.deptId <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p><strong>场景5: B的独有（查询没有任何员工的部门）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">right</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">where</span> t_emp.empno <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p><strong>场景6:  AB全有（查询所有员工和所有部门）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">left</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">right</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br></pre></td></tr></table></figure><p><strong>场景7: A的独有+B的独有（查询没有加入任何部门的员工，以及查询出部门下没有任何员工的部门）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">left</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">where</span> t_emp.deptId <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">right</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">where</span> t_emp.empno <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h3 id="5-3-2-join查询进阶"><a href="#5-3-2-join查询进阶" class="headerlink" title="5.3.2 join查询进阶"></a>5.3.2 join查询进阶</h3><p>增加掌门人字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_dept <span class="keyword">ADD</span> CEO <span class="type">INT</span>(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">4</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">6</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">8</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">9</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><strong>场景8: 求各个门派对应的掌门人名称</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_dept.deptName, t_emp.name</span><br><span class="line"><span class="keyword">from</span> t_dept <span class="keyword">inner</span> <span class="keyword">join</span> t_emp <span class="keyword">on</span>  t_dept.CEO <span class="operator">=</span> t_emp.id</span><br></pre></td></tr></table></figure><p><strong>场景9: 求所有当上掌门人的平均年龄:</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">AVG</span>(t_emp.age)</span><br><span class="line"><span class="keyword">from</span> t_dept <span class="keyword">inner</span> <span class="keyword">join</span> t_emp <span class="keyword">on</span>  t_dept.CEO <span class="operator">=</span> t_emp.id</span><br></pre></td></tr></table></figure><p><strong>场景10: 求所有人物对应的掌门名称</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#临时表连接方式<span class="number">1</span><span class="comment">---部门和ceo关系</span></span><br><span class="line"><span class="keyword">SELECT</span> c.name,ab.ceoname <span class="keyword">FROM</span> t_emp c <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">( <span class="keyword">SELECT</span> b.id <span class="keyword">AS</span> deptId,a.name <span class="keyword">AS</span> ceoname <span class="keyword">FROM</span> t_emp a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_dept b <span class="keyword">ON</span> a.id <span class="operator">=</span> b.ceo ) ab</span><br><span class="line"><span class="keyword">ON</span> c.deptId <span class="operator">=</span> ab.deptId ;</span><br><span class="line"></span><br><span class="line">#临时表连接方式<span class="number">2</span><span class="comment">---人和CEO关系</span></span><br><span class="line"><span class="keyword">SELECT</span> ab.name,c.name <span class="keyword">AS</span> ceoname <span class="keyword">FROM</span> </span><br><span class="line">( <span class="keyword">SELECT</span> a.name,b.ceo <span class="keyword">FROM</span> t_emp a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_dept b <span class="keyword">ON</span> a.deptid <span class="operator">=</span> b.id ) ab</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_emp c <span class="keyword">ON</span> ab.ceo <span class="operator">=</span> c.id ;</span><br><span class="line"></span><br><span class="line">#三表左连接方式</span><br><span class="line"><span class="keyword">SELECT</span> a.name,c.name <span class="keyword">AS</span> ceoname <span class="keyword">FROM</span> t_emp a </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_dept b <span class="keyword">ON</span> a.deptid <span class="operator">=</span> b.id </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_emp c <span class="keyword">ON</span> b.ceo <span class="operator">=</span> c.id ;</span><br><span class="line"></span><br><span class="line">#子查询方式</span><br><span class="line"><span class="keyword">SELECT</span> a.name ,(<span class="keyword">SELECT</span> c.name <span class="keyword">FROM</span> t_emp c <span class="keyword">WHERE</span> c.id<span class="operator">=</span>b.ceo) <span class="keyword">AS</span> ceoname</span><br><span class="line"><span class="keyword">FROM</span> t_emp a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_dept b </span><br><span class="line"><span class="keyword">ON</span> a.deptid <span class="operator">=</span> b.id ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mysql逻辑架构(理论)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;索引(数</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="逻辑架构" scheme="http://example.com/tags/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"/>
    
    <category term="存储引擎" scheme="http://example.com/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    <category term="索引" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="SQL优化" scheme="http://example.com/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
