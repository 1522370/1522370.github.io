<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LH Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-12-04T08:04:21.952Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>香蕉BU娇</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL</title>
    <link href="http://example.com/2022/12/02/MySQL/"/>
    <id>http://example.com/2022/12/02/MySQL/</id>
    <published>2022-12-02T15:39:17.000Z</published>
    <updated>2022-12-04T08:04:21.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ul><li><strong>mysql逻辑架构(理论)</strong></li><li><strong>索引(数据结构): mysql为什么要使用b+树</strong></li><li><strong>存储引擎: 5种</strong></li><li><strong>join查询</strong></li></ul><h1 id="1-逻辑架构"><a href="#1-逻辑架构" class="headerlink" title="1 逻辑架构"></a>1 逻辑架构</h1><h2 id="1-1-架构概览"><a href="#1-1-架构概览" class="headerlink" title="1.1 架构概览"></a>1.1 架构概览</h2><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。</p><p>这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 </p><p><img src="/2022/12/02/MySQL/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="逻辑架构图"></p><p>简单理解即为：</p><p><img src="/2022/12/02/MySQL/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png"></p><h3 id="1-1-1-连接层"><a href="#1-1-1-连接层" class="headerlink" title="1.1.1 连接层"></a>1.1.1 连接层</h3><p>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。</p><p>主要完成一些类似于连接处理、授权认证、及相关的安全方案。</p><p>在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。</p><p>同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 </p><h3 id="1-1-2-服务层"><a href="#1-1-2-服务层" class="headerlink" title="1.1.2 服务层"></a>1.1.2 服务层</h3><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。</p><p>所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p><p>在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。</p><p>如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><p>2.1 Management Serveices &amp; Utilities： 系统管理和控制工具 </p><p>2.2 SQL Interface: SQL接口</p><ul><li>接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</li></ul><p>2.3 Parser: 解析器</p><ul><li>SQL命令传递到解析器的时候会被解析器验证和解析。 </li></ul><p>2.4 Optimizer: 查询优化器。（索引命中）</p><ul><li>SQL语句在查询之前会使用查询优化器对查询进行优化。 </li><li>用一个例子就可以理解： select uid,name from user where gender= 1;</li><li>优化器来决定先投影还是先过滤。 </li></ul><p>2.5 Cache和Buffer： 查询缓存。</p><ul><li>如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 </li></ul><h3 id="1-1-3-引擎层"><a href="#1-1-3-引擎层" class="headerlink" title="1.1.3 引擎层"></a>1.1.3 引擎层</h3><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB </p><h3 id="1-1-4-存储层"><a href="#1-1-4-存储层" class="headerlink" title="1.1.4 存储层"></a>1.1.4 存储层</h3><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。 </p><h2 id="1-2-show-profiles"><a href="#1-2-show-profiles" class="headerlink" title="1.2 show profiles"></a>1.2 show profiles</h2><p>了解查询语句底层执行的过程：select @@profiling;查看是否开启计划。</p><ol><li>  修改配置文件/etc/my.cnf，先开启查询缓存</li></ol><p>新增一行：query_cache_type=1</p><p>重启mysql：systemctl restart mysqld</p><ol start="2"><li>  再开启查询执行计划</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%profiling%&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure><ol start="3"><li>  执行语句两次：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mydb.mytbl <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure><ol start="4"><li>  显示最近执行的语句</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profiles; </span><br></pre></td></tr></table></figure><p><img src="/2022/12/02/MySQL/image-20210602092918061.png" alt="image-20210602092918061"></p><ol start="5"><li>  显示执行计划</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile cpu,block io <span class="keyword">for</span> query <span class="number">6</span>; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/02/MySQL/image-20210602092929003.png" alt="image-20210602092929003"></p><p><img src="/2022/12/02/MySQL/image-20210602092950982.png" alt="image-20210602092950982"></p><p>执行编号7时，比执行编号6时少了很多信息，从下面截图中可以看出查询语句直接从缓存中获取数据；</p><p>==<strong>注意：SQL必须是一致的，否则，不能命中缓存。</strong>==</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#虽然查询结果一致，但并没有命中缓存。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mydb.mytbl <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mydb.mytbl <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">1</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="1-3-工作流程"><a href="#1-3-工作流程" class="headerlink" title="1.3 工作流程"></a>1.3 工作流程</h2><p>==<strong>mysql的查询流程：</strong>==</p><ol><li>首先，mysql客户端通过协议与mysql服务器建连接，发送查询语句，先检查查询缓存，如果命中，直接返回结果，否则进行语句解析，也就是说，在解析查询之前，服务器会先访问查询缓存(query cache)——它存储SELECT语句以及相应的查询结果集。</li><li>如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。</li><li>语法解析器和预处理：首先mysql通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”。</li><li>mysql解析器将使用mysql语法规则验证和解析查询；</li><li>预处理器则根据一些mysql规则进一步检查解析树是否合法。 </li><li>查询优化器当解析树被认为是合法的了，并且由优化器将其转化成执行计划。</li><li>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。 </li><li>mysql默认使用的BTREE索引，并且一个大致方向是：无论怎么折腾sql，至少在目前来说，mysql最多只用到表中的一个索引。</li></ol><h1 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2 存储引擎"></a>2 存储引擎</h1><h2 id="2-1-查看存储引擎"><a href="#2-1-查看存储引擎" class="headerlink" title="2.1 查看存储引擎"></a>2.1 查看存储引擎</h2><p>查看mysql提供什么存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/02/MySQL/image-20210602093145257.png" alt="image-20210602093145257"></p><p>查看默认的存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>; </span><br></pre></td></tr></table></figure><p><img src="/2022/12/02/MySQL/image-20210602093209298.png" alt="image-20210602093209298"></p><h2 id="2-2-引擎介绍"><a href="#2-2-引擎介绍" class="headerlink" title="2.2 引擎介绍"></a>2.2 引擎介绍</h2><h3 id="2-2-1-InnoDB"><a href="#2-2-1-InnoDB" class="headerlink" title="2.2.1 InnoDB"></a>2.2.1 InnoDB</h3><ul><li><strong>大于等于5.5之后，默认采用InnoDB引擎</strong>。</li><li>InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li><li>除了增加和查询外，还需要更新，删除操作，那么，应优选选择InnoDB存储引擎。</li><li>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</li></ul><h3 id="2-2-2-MyISAM"><a href="#2-2-2-MyISAM" class="headerlink" title="2.2.2 MyISAM"></a>2.2.2 MyISAM</h3><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务和行级锁，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</li><li>5.5之前默认的存储引擎</li><li>数据文件结构：<ul><li>.frm 存储定义表</li><li>.MYD 存储数据</li><li>.MYI 存储索引</li></ul></li></ul><p>==<strong>特别注意：</strong>==</p><ul><li>静态表字段都是非变长字段，存储占用空间比动态表多。存储数据时会按照列宽补足空格，但在访问时候并不会得到这些空格。</li><li>如果存储数据本身后面有空格，那么，查询时也会被去掉。</li><li>如果存储数据本身前面有空格，则查询时不会被去掉。</li><li>在没有where条件情况下统计表count(*)数量，不需要全表扫描，而是直接获取保存好的值。</li></ul><h3 id="2-2-3-Archive"><a href="#2-2-3-Archive" class="headerlink" title="2.2.3 Archive"></a>2.2.3 Archive</h3><ul><li>Archive档案存储引擎只支持<strong>INSERT</strong>和<strong>SELECT</strong>操作，在MySQL5.1之前不支持索引。</li><li>Archive表<strong>适合日志和数据采集（档案）</strong>类应用。</li><li>根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。</li></ul><h3 id="2-2-4-Blackhole"><a href="#2-2-4-Blackhole" class="headerlink" title="2.2.4 Blackhole"></a>2.2.4 Blackhole</h3><ul><li>Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。</li><li>但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。</li></ul><h3 id="2-2-5-CSV"><a href="#2-2-5-CSV" class="headerlink" title="2.2.5 CSV"></a>2.2.5 CSV</h3><ul><li>CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。</li><li>CSV引擎可以作为一种数据交换的机制，非常有用。</li><li>CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。</li></ul><h3 id="2-2-6-Memory引擎"><a href="#2-2-6-Memory引擎" class="headerlink" title="2.2.6 Memory引擎"></a>2.2.6 Memory引擎</h3><ul><li>如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。</li><li>Memory表至少比MyISAM表要快一个数量级。</li></ul><h3 id="2-2-7-Federated引擎"><a href="#2-2-7-Federated引擎" class="headerlink" title="2.2.7 Federated引擎"></a>2.2.7 Federated引擎</h3><ul><li>Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li></ul><h2 id="2-3-MyISAM和InnoDB"><a href="#2-3-MyISAM和InnoDB" class="headerlink" title="2.3 MyISAM和InnoDB"></a>2.3 MyISAM和InnoDB</h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr><tr><td>关注点</td><td>性能：节省资源、消耗少、简单业务</td><td>事务：并发写、事务、更大资源</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr></tbody></table><h1 id="3-索引入门"><a href="#3-索引入门" class="headerlink" title="3 索引入门"></a>3 索引入门</h1><h2 id="3-1-索引简介"><a href="#3-1-索引简介" class="headerlink" title="3.1 索引简介"></a>3.1 索引简介</h2><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL<strong>高效获取数据的数据结构</strong>。 </p><p>索引的本质：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”。</p><p>下图就是一种可能的索引方式示例：</p><p><img src="/2022/12/02/MySQL/image-20210602100619962.png" alt="image-20210602100619962">  </p><p><strong>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址</strong></p><p>为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</p><p>数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是<strong>索引</strong>。</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往<strong>以索引文件形式存储磁盘上</strong></p><h2 id="3-2-优点与缺点"><a href="#3-2-优点与缺点" class="headerlink" title="3.2 优点与缺点"></a>3.2 优点与缺点</h2><p>优点:</p><ul><li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li></ul><p>缺点:</p><ul><li><p>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以<strong>索引列也是要占用空间</strong>的</p></li><li><p>虽然索引大大提高了查询速度，同时却会<strong>降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。 因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</p></li></ul><h2 id="3-3-索引结构"><a href="#3-3-索引结构" class="headerlink" title="3.3 索引结构"></a>3.3 索引结构</h2><h3 id="3-3-1-Hash"><a href="#3-3-1-Hash" class="headerlink" title="3.3.1 Hash"></a>3.3.1 Hash</h3><p>加速查找速度的数据结构，常见的有两类：</p><p>(1)哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是O(1)；</p><p>哈希索引：</p><p><img src="/2022/12/02/MySQL/%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95-1670137812737.png"></p><p>(2)树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是O(log2N)；</p><p>可以看到，不管是读请求，还是写请求，哈希类型的索引，都要比树型的索引更快一些，</p><p><strong>那为什么，索引结构要设计成树型呢？</strong></p><p>想想<strong>范围/排序</strong>等其它SQL条件：</p><p>哈希型的索引，时间复杂度会退化为O(n)而<strong>树型的“有序”特性</strong>，依然能够保持O(log2N) 的高效率。</p><p>备注：InnoDB并不支持哈希索引。</p><h3 id="3-3-2-时间复杂度"><a href="#3-3-2-时间复杂度" class="headerlink" title="3.3.2 时间复杂度"></a>3.3.2 时间复杂度</h3><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。</p><p><img src="/2022/12/02/MySQL/image-20210602100853184.png" alt="image-20210602100853184"></p><p><img src="/2022/12/02/MySQL/image-20210602100858992.png" alt="image-20210602100858992"></p><h3 id="3-3-3-普通二叉树"><a href="#3-3-3-普通二叉树" class="headerlink" title="3.3.3 普通二叉树"></a>3.3.3 普通二叉树</h3><p>二叉树的特点：</p><ul><li>一个节点只能有两个子节点，也就是一个节点度不能超过2</li><li>左子节点 小于 本节点；右子节点大于等于 本节点，比我大的向右，比我小的向左</li></ul><p><img src="/2022/12/02/MySQL/image-20210602100943179.png" alt="image-20210602100943179"></p><p>对该二叉树的节点进行查找</p><ul><li><p>深度为1的节点的查找次数为1，</p></li><li><p>深度为2的节点的查找次数为2，</p></li><li><p>深度为N的节点的查找次数为N，</p></li></ul><p>结论：因此其平均查找次数为 (1+2+2+3+3+3) / 6 = 2.3次</p><blockquote><p>每次查找数据可以字节丢弃50%的数据进行查找，提高查找效率</p></blockquote><h3 id="3-3-4-平衡二叉树"><a href="#3-3-4-平衡二叉树" class="headerlink" title="3.3.4 平衡二叉树"></a>3.3.4 平衡二叉树</h3><p><strong>平衡二叉树</strong>（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：</p><p><strong>==它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。==</strong></p><p><code>这个方案很好的解决了二叉查找树退化成链表的问题</code>，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。</p><p><img src="/2022/12/02/MySQL/image-20210602101040214.png" alt="image-20210602101040214"></p><p>平衡二叉树大部分操作和二叉查找树类似，主要不同在于插入删除的时候平衡二叉树的平衡可能被改变，并且只有从那些插入点到根结点的路径上的结点的平衡性可能被改变，因为只有这些结点的子树可能变化。</p><h3 id="3-3-5-BTree-重点"><a href="#3-3-5-BTree-重点" class="headerlink" title="3.3.5 BTree(重点)"></a>3.3.5 BTree(重点)</h3><p><strong>B-Tree树即</strong>B树，B即Balanced，平衡的意思。</p><p><strong>B树的阶：</strong>节点的最多子节点个数。</p><p>B树的搜索，从根结点开始，对节点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点；重复，直到所对应的儿子指针为空，或已经是叶子节点, 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据, 搜索有可能在非叶子节点结束,其搜索性能等价于在关键字全集内做一次二分查找</p><p><img src="/2022/12/02/MySQL/image-20210602101333676.png" alt="image-20210602101333676"></p><p><strong>那么，我们思考一个问题，索引树会一次性加载吗？</strong></p><ul><li><code>数据库索引是存储在磁盘上的，如果数据很大，必然导致索引的大小也会很大，超过几个G</code>（好比新华字典字数多必然导致目录厚</li><li>当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：</li><li>逐一加载每一个<strong>磁盘页</strong>，因为磁盘页对应着索引树的节点。</li></ul><p> <img src="/2022/12/02/MySQL/image-20210602101455325.png" alt="image-20210602101455325"></p><p><strong>页</strong></p><p>Page是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在Page结构里。</p><p>Page分为几种类型：<strong>数据页（B-Tree Node），Undo页（Undo Log Page），系统页（System Page），事务数据页（Transaction System Page）</strong>等；**==每个数据页的大小为16kb==**，每个Page使用一个32位（一位表示的就是0或1）的int值来表示，正好对应Innodb最大64TB的存储容量(16kb * 2^32=64tib)</p><p><img src="/2022/12/02/MySQL/image-20210602101656506.png" alt="image-20210602101656506"></p><p><strong>块</strong></p><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB存储引擎中有页（Page）的概念，系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p><p>==<strong>Btree的查询流程</strong>==</p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。</p><p>模拟查找关键字29的过程：</p><ul><li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li><li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li><li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li><li>在磁盘块8中的关键字列表中找到关键字29。</li></ul><p>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个BTree查找效率的决定因素。</p><p><strong>BTree相对于AVLTree每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</strong></p><h3 id="3-3-6-B-Tree-重点"><a href="#3-3-6-B-Tree-重点" class="headerlink" title="3.3.6 B+Tree(重点)"></a>3.3.6 B+Tree(重点)</h3><p>  B+树是B树的变体，也是一种多路搜索树。B+树的搜索与B树也基本相同，区别是B+树只有达到叶子节点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</p><p>**==所有关键字都出现在叶子节点的链表中（即数据只能在叶子节点）==**，且链表中的关键字(数据)恰好是有序的。因此不可能在非叶子节点命中, <strong>==非叶子节点相当于是叶子节点的索引，叶子节点相当于是存储（关键字）数据的数据层==</strong></p><p><img src="/2022/12/02/MySQL/image-20210602102758064.png" alt="image-20210602102758064"></p><p>通常在 B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。 因此可以对 B+Tree 进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。 </p><p>InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用 4 个字节）或 BIGINT（占用 8 个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 16KB/(8B+8B)=1K 个键值（因为是估值，为方便计算，这里的 K 取值为 10^3。也就是说一个深度为 3 的 B+Tree 索引可以维护 10^3 _ 10^3 _ 10^3 = 10 亿条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2<del>4 层。MySQL 的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1</del>3 次磁盘 I/O 操作。</p><p>==<strong>BTree和B+Tree比较</strong>==</p><ul><li><strong>B</strong>树结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B树的深度较大，增大查询时的磁盘I/O次数进而影响查询效率。</li><li><strong>B+树</strong>中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+树的高度。</li></ul><h2 id="3-4-聚簇与非聚簇索引-重点"><a href="#3-4-聚簇与非聚簇索引-重点" class="headerlink" title="3.4 聚簇与非聚簇索引(重点)"></a>3.4 聚簇与非聚簇索引(重点)</h2><h3 id="3-4-1-聚簇索引"><a href="#3-4-1-聚簇索引" class="headerlink" title="3.4.1 聚簇索引"></a>3.4.1 聚簇索引</h3><p><strong>聚簇索引</strong>并不是一种单独的索引类型，而<strong>是一种数据存储方式</strong>。聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。</p><p>Innodb通过主键聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引。</p><p><strong>优点：</strong></p><ul><li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快</li></ul><p><strong>缺点：</strong></p><ul><li>插入速度严重依赖于插入顺序，按照主键的<strong>顺序插入</strong>是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列为主键</strong></li><li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</li></ul><h3 id="3-4-2-非聚簇索引"><a href="#3-4-2-非聚簇索引" class="headerlink" title="3.4.2 非聚簇索引"></a>3.4.2 非聚簇索引</h3><p>在<strong>聚簇索引之上创建的索引称之为非聚簇索引</strong>，非聚簇索引访问数据总是需要二次查找。非聚簇索引叶子节点存储的不再是行的物理位置，而是主键值。通过非聚簇索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。</p><p>Innodb非聚簇索引的叶子节点并<strong>不包含行记录的全部数据</strong>，叶子节点除了包含键值外，还包含了相应行数据的聚簇索引键。</p><p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。在innodb中有时也称非聚簇索引为二级索引或辅助索引。</p><h2 id="3-5-小结-笔记"><a href="#3-5-小结-笔记" class="headerlink" title="3.5 小结(笔记)"></a>3.5 小结(笔记)</h2><ul><li>数据库索引用于加速查询</li><li>虽然哈希索引是 O(1)，树索引是 O(log(n))，但 SQL 有很多“有序”需求，故数据库使用树型索引</li><li>InnoDB 不支持哈希索引</li><li>数据预读的思路是：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘 IO</li><li>数据库的索引最常用 B+树： <ul><li>很适合磁盘存储，能够充分利用局部性原理，磁盘预读； </li><li>很低的树高度，能够存储大量数据；</li><li>索引本身占用的内存很小；</li><li>能够很好的支持单点查询，范围查询，有序性查询；</li></ul></li></ul><h1 id="4-MySQL索引"><a href="#4-MySQL索引" class="headerlink" title="4 MySQL索引"></a>4 MySQL索引</h1><h2 id="4-1-单值索引"><a href="#4-1-单值索引" class="headerlink" title="4.1 单值索引"></a>4.1 单值索引</h2><p>即一个索引只包含单个列，一个表可以有多个单列索引，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">随表一起建索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">  KEY (customer_name)</span><br><span class="line">);</span><br><span class="line">单独建单值索引：</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_customer_name <span class="keyword">ON</span> customer(customer_name); </span><br><span class="line">删除索引：</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_customer_name  <span class="keyword">on</span> customer;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-2-唯一索引"><a href="#4-2-唯一索引" class="headerlink" title="4.2 唯一索引"></a>4.2 唯一索引</h2><p>索引列的值必须唯一，但允许有空值，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">随表一起建索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">  KEY (customer_name),</span><br><span class="line">  <span class="keyword">UNIQUE</span> (customer_no)</span><br><span class="line">);</span><br><span class="line">单独建唯一索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_customer_no <span class="keyword">ON</span> customer(customer_no); </span><br><span class="line">删除索引：</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_customer_no <span class="keyword">on</span> customer ;</span><br></pre></td></tr></table></figure><h2 id="4-3-主键索引"><a href="#4-3-主键索引" class="headerlink" title="4.3 主键索引"></a>4.3 主键索引</h2><p>设定为主键后数据库会自动建立索引（不能有null），<strong>innodb</strong>为聚簇索引，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">随表一起建索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer2 (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED   ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>) </span><br><span class="line">);</span><br><span class="line">单独建主键索引：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customer2 <span class="keyword">add</span> <span class="keyword">PRIMARY</span> KEY customer2(id);  </span><br><span class="line">删除主键索引：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customer2 <span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY ;  </span><br><span class="line">修改主键索引：</span><br><span class="line">必须先删除掉(<span class="keyword">drop</span>)原索引，再新建(<span class="keyword">add</span>)索引</span><br></pre></td></tr></table></figure><h2 id="4-4-复合索引"><a href="#4-4-复合索引" class="headerlink" title="4.4 复合索引"></a>4.4 复合索引</h2><p>即一个索引包含多个列，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 随表一起建索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">  KEY (customer_name),</span><br><span class="line">  <span class="keyword">UNIQUE</span> (customer_name),</span><br><span class="line">  KEY (customer_no,customer_name)</span><br><span class="line">);</span><br><span class="line">单独建索引：</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_customer_no_name <span class="keyword">ON</span> customer(customer_no,customer_name); </span><br><span class="line">删除索引：</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_customer_no_name  <span class="keyword">on</span> customer ;</span><br></pre></td></tr></table></figure><h2 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5 小结"></a>4.5 小结</h2><p>==<strong>哪些情况需要创建索引</strong>==</p><ul><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题，who？(在高并发下倾向创建组合索引)</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ul><p><strong>==哪些情况不要创建索引==</strong></p><ul><li><p>表记录太少，300万数据时MySQL性能就开始下降了，这时就可以开始开始优化了</p></li><li><p>经常增删改的表，提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件</p></li><li><p>where条件里用不到的字段</p></li><li><p>数据重复过滤性不好的字段</p></li></ul><h1 id="5-SQL优化-重点"><a href="#5-SQL优化-重点" class="headerlink" title="5 SQL优化(重点)"></a>5 SQL优化(重点)</h1><h2 id="5-1-SQL执行顺序"><a href="#5-1-SQL执行顺序" class="headerlink" title="5.1 SQL执行顺序"></a>5.1 SQL执行顺序</h2><p><img src="/2022/12/02/MySQL/image-20210602104459899.png" alt="image-20210602104459899"></p><p>从这个顺序中我们不难发现，所有的查询语句都是从from开始执行的，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。<br><strong>第一步：</strong>首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 <strong>vt1</strong>（选择相对小的表做基础表） </p><p><strong>第二步：</strong>接下来便是应用on筛选器，on中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 <strong>vt2</strong> </p><p><strong>第三步：</strong>如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 <strong>vt3</strong> </p><p><strong>第四步：</strong>如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3</p><p><strong>第五步：</strong>应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表<strong>vt4</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">注意</span>:<span class="string">对于包含outer join子句的查询，到底在on筛选器还是用where筛选器指定逻辑表达式呢？</span></span><br><span class="line"><span class="attr">on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer</span> <span class="string">join中还可以把移除的行再次添加回来，而where的移除的最终的。</span></span><br><span class="line"><span class="attr">举个简单的例子</span>:<span class="string"></span></span><br><span class="line"><span class="attr">有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。</span></span><br><span class="line"><span class="attr">为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名</span>=<span class="string">成绩.姓名）</span></span><br><span class="line"><span class="attr">那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了</span></span><br><span class="line"><span class="attr">但是我们用left</span> <span class="string">outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生</span></span><br><span class="line"><span class="attr">如果在on中应用学生.班级</span>=<span class="string">&#x27;x&#x27;的话，left outer join会把x班级的所有学生记录找回</span></span><br><span class="line"><span class="attr">所以只能在where筛选器中应用学生.班级</span>=<span class="string">&#x27;x&#x27; 因为它的过滤是最终的。 </span></span><br><span class="line"><span class="attr">总结</span>: <span class="string">最终过滤条件放在where语句中,on语句做数据匹配不要做筛选!!!</span></span><br></pre></td></tr></table></figure><p><strong>第六步：</strong>group by 子句将中的唯一的值组合成为一组，得到虚拟表<strong>vt5</strong>。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。==原因在于最终的结果集中只为每个组包含一行,这一点请牢记。== </p><p><strong>第七步：</strong>应用cube或者rollup选项，为vt5生成超组，生成<strong>vt6</strong></p><p>[^ROLLUP]: 是GROUP BY子句的一种扩展，可以为每个分组返回小计记录以及为所有分组返回总计记录。<br>[^CUBE]: 也是GROUP BY子句的一种扩展，可以返回每一个列组合的小计记录，同时在末尾加上总计记录。</p><p><strong>第八步：</strong>应用having筛选器，生成<strong>vt7</strong>。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器</p><p><strong>第九步：</strong>处理select子句。将vt7中的在select中出现的列筛选出来。生成<strong>vt8</strong></p><p><strong>第十步：</strong>应用distinct子句，vt8中移除相同的行，生成<strong>vt9</strong></p><p>[^注意]: ==如果应用了group by子句那么distinct是多余的，原因同样在于分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的==</p><p><strong>第十一步：</strong>应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表</p><p>[^游标]: sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。</p><p><strong>第十二步：</strong>返回结果给请求者即用户 </p><h2 id="5-2-测试数据"><a href="#5-2-测试数据" class="headerlink" title="5.2 测试数据"></a>5.2 测试数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_dept` (</span><br><span class="line"> `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `deptName` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `address` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_emp` (</span><br><span class="line"> `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `deptId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`empno` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"> KEY `idx_dept_id` (`deptId`)</span><br><span class="line"> #<span class="keyword">CONSTRAINT</span> `fk_dept_id` <span class="keyword">FOREIGN</span> KEY (`deptId`) <span class="keyword">REFERENCES</span> `t_dept` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;华山&#x27;</span>,<span class="string">&#x27;华山&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;丐帮&#x27;</span>,<span class="string">&#x27;洛阳&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;峨眉&#x27;</span>,<span class="string">&#x27;峨眉山&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">&#x27;武当&#x27;</span>,<span class="string">&#x27;武当山&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">&#x27;明教&#x27;</span>,<span class="string">&#x27;光明顶&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">&#x27;少林&#x27;</span>,<span class="string">&#x27;少林寺&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;风清扬&#x27;</span>,<span class="number">90</span>,<span class="number">1</span>,<span class="number">100001</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;岳不群&#x27;</span>,<span class="number">50</span>,<span class="number">1</span>,<span class="number">100002</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;令狐冲&#x27;</span>,<span class="number">24</span>,<span class="number">1</span>,<span class="number">100003</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">&#x27;洪七公&#x27;</span>,<span class="number">70</span>,<span class="number">2</span>,<span class="number">100004</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">&#x27;乔峰&#x27;</span>,<span class="number">35</span>,<span class="number">2</span>,<span class="number">100005</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">&#x27;灭绝师太&#x27;</span>,<span class="number">70</span>,<span class="number">3</span>,<span class="number">100006</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">7</span>,<span class="string">&#x27;周芷若&#x27;</span>,<span class="number">20</span>,<span class="number">3</span>,<span class="number">100007</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">8</span>,<span class="string">&#x27;张三丰&#x27;</span>,<span class="number">100</span>,<span class="number">4</span>,<span class="number">100008</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">9</span>,<span class="string">&#x27;张无忌&#x27;</span>,<span class="number">25</span>,<span class="number">5</span>,<span class="number">100009</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">10</span>,<span class="string">&#x27;韦小宝&#x27;</span>,<span class="number">18</span>,<span class="keyword">NULL</span>,<span class="number">100010</span>);</span><br></pre></td></tr></table></figure><h2 id="5-3-JOIN查询"><a href="#5-3-JOIN查询" class="headerlink" title="5.3 JOIN查询"></a>5.3 JOIN查询</h2><h3 id="5-3-1-join查询入门"><a href="#5-3-1-join查询入门" class="headerlink" title="5.3.1 join查询入门"></a>5.3.1 join查询入门</h3><p><strong>场景1: A、B两表共有(查询所有有部门的员工-&gt;员工和部门之间必须存在关联的数据)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">inner</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br></pre></td></tr></table></figure><p><strong>场景2:  A、B两表共有+A的独有（列出所有用户，并显示其机构信息）A的全集</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">left</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br></pre></td></tr></table></figure><p><strong>场景3: A、B两表共有+B的独有（列出所有部门，并显示其部门的员工信息 ）B的全集</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">right</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br></pre></td></tr></table></figure><p><strong>场景4: A的独有 （查询没有加入任何部门的员工）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">left</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">where</span> t_emp.deptId <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p><strong>场景5: B的独有（查询没有任何员工的部门）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">right</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">where</span> t_emp.empno <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p><strong>场景6:  AB全有（查询所有员工和所有部门）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">left</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">right</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br></pre></td></tr></table></figure><p><strong>场景7: A的独有+B的独有（查询没有加入任何部门的员工，以及查询出部门下没有任何员工的部门）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">left</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">where</span> t_emp.deptId <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">right</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">where</span> t_emp.empno <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h3 id="5-3-2-join查询进阶"><a href="#5-3-2-join查询进阶" class="headerlink" title="5.3.2 join查询进阶"></a>5.3.2 join查询进阶</h3><p>增加掌门人字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_dept <span class="keyword">ADD</span> CEO <span class="type">INT</span>(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">4</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">6</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">8</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">9</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><strong>场景8: 求各个门派对应的掌门人名称</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_dept.deptName, t_emp.name</span><br><span class="line"><span class="keyword">from</span> t_dept <span class="keyword">inner</span> <span class="keyword">join</span> t_emp <span class="keyword">on</span>  t_dept.CEO <span class="operator">=</span> t_emp.id</span><br></pre></td></tr></table></figure><p><strong>场景9: 求所有当上掌门人的平均年龄:</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">AVG</span>(t_emp.age)</span><br><span class="line"><span class="keyword">from</span> t_dept <span class="keyword">inner</span> <span class="keyword">join</span> t_emp <span class="keyword">on</span>  t_dept.CEO <span class="operator">=</span> t_emp.id</span><br></pre></td></tr></table></figure><p><strong>场景10: 求所有人物对应的掌门名称</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#临时表连接方式<span class="number">1</span><span class="comment">---部门和ceo关系</span></span><br><span class="line"><span class="keyword">SELECT</span> c.name,ab.ceoname <span class="keyword">FROM</span> t_emp c <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">( <span class="keyword">SELECT</span> b.id <span class="keyword">AS</span> deptId,a.name <span class="keyword">AS</span> ceoname <span class="keyword">FROM</span> t_emp a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_dept b <span class="keyword">ON</span> a.id <span class="operator">=</span> b.ceo ) ab</span><br><span class="line"><span class="keyword">ON</span> c.deptId <span class="operator">=</span> ab.deptId ;</span><br><span class="line"></span><br><span class="line">#临时表连接方式<span class="number">2</span><span class="comment">---人和CEO关系</span></span><br><span class="line"><span class="keyword">SELECT</span> ab.name,c.name <span class="keyword">AS</span> ceoname <span class="keyword">FROM</span> </span><br><span class="line">( <span class="keyword">SELECT</span> a.name,b.ceo <span class="keyword">FROM</span> t_emp a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_dept b <span class="keyword">ON</span> a.deptid <span class="operator">=</span> b.id ) ab</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_emp c <span class="keyword">ON</span> ab.ceo <span class="operator">=</span> c.id ;</span><br><span class="line"></span><br><span class="line">#三表左连接方式</span><br><span class="line"><span class="keyword">SELECT</span> a.name,c.name <span class="keyword">AS</span> ceoname <span class="keyword">FROM</span> t_emp a </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_dept b <span class="keyword">ON</span> a.deptid <span class="operator">=</span> b.id </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_emp c <span class="keyword">ON</span> b.ceo <span class="operator">=</span> c.id ;</span><br><span class="line"></span><br><span class="line">#子查询方式</span><br><span class="line"><span class="keyword">SELECT</span> a.name ,(<span class="keyword">SELECT</span> c.name <span class="keyword">FROM</span> t_emp c <span class="keyword">WHERE</span> c.id<span class="operator">=</span>b.ceo) <span class="keyword">AS</span> ceoname</span><br><span class="line"><span class="keyword">FROM</span> t_emp a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_dept b </span><br><span class="line"><span class="keyword">ON</span> a.deptid <span class="operator">=</span> b.id ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mysql逻辑架构(理论)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;索引(数</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="逻辑架构" scheme="http://example.com/tags/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"/>
    
    <category term="存储引擎" scheme="http://example.com/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    <category term="索引" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="SQL优化" scheme="http://example.com/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/11/23/hello-world/"/>
    <id>http://example.com/2022/11/23/hello-world/</id>
    <published>2022-11-23T06:26:25.992Z</published>
    <updated>2022-11-26T06:29:02.448Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="hello" scheme="http://example.com/categories/hello/"/>
    
    
    <category term="jQuery" scheme="http://example.com/tags/jQuery/"/>
    
    <category term="表格" scheme="http://example.com/tags/%E8%A1%A8%E6%A0%BC/"/>
    
    <category term="表单验证" scheme="http://example.com/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
</feed>
