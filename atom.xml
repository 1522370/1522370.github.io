<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LH Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-12-04T16:38:06.896Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>香蕉BU娇</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL高级</title>
    <link href="http://example.com/2022/12/04/MySQL%E9%AB%98%E7%BA%A7/"/>
    <id>http://example.com/2022/12/04/MySQL%E9%AB%98%E7%BA%A7/</id>
    <published>2022-12-04T10:53:47.000Z</published>
    <updated>2022-12-04T16:38:06.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><ul><li>MySQL的索引（理论）</li><li>如何让索引生效？（理论）—&gt;这个索引生效还是未生效？（操作）</li></ul><h2 id="1-Explain"><a href="#1-Explain" class="headerlink" title="1. Explain"></a>1. Explain</h2><p>MySQL中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间）</p><p>当客户端向MySQL 请求一条Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给MySQL Query Optimizer时，MySQL Query Optimizer 首先会对整条Query进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息（如果有），看显示Hint信息是否可以完全确定该Query 的执行计划。如果没有 Hint 或Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。 </p><h2 id="1-1-Explain简介"><a href="#1-1-Explain简介" class="headerlink" title="1.1 Explain简介"></a>1.1 Explain简介</h2><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是 如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p><p>EXPLAIN功能: 表的读取顺序，数据读取操作的操作类型，哪些索引可以使用，哪些索引被实际使用，表之间的引用，每张表有多少行被优化器查询等内容。</p><p>使用方式为：Explain + SQL语句</p><p>EXPLAIN出来的信息有10列，分别是<strong>id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</strong></p><p><strong>id: 选择标识符</strong></p><p><strong>select_type: 表示查询的类型</strong></p><p><strong>table: 输出结果集的表</strong></p><p><strong>partitions: 匹配的分区</strong></p><p><strong>type: 表示表的连接类型</strong></p><p><strong>possible_keys: 表示查询时，可能使用的索引</strong></p><p><strong>key: 表示实际使用的索引</strong></p><p><strong>key_len: 索引字段的长度</strong></p><p><strong>ref: 列与索引的比较</strong></p><p><strong>rows: 扫描出的行数(估算的行数)</strong></p><p><strong>filtered: 按表条件过滤的行百分比</strong></p><p><strong>Extra: 执行情况的描述和说明</strong></p><p>创建一下数据库表和数据，接下来进行explain的详细学习</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT,content  <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span> ,  <span class="keyword">PRIMARY</span> KEY (id));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT,content  <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span> ,  <span class="keyword">PRIMARY</span> KEY (id));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT,content  <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span> ,  <span class="keyword">PRIMARY</span> KEY (id));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t4(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT,content  <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span> ,  <span class="keyword">PRIMARY</span> KEY (id));</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1(content) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t1_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>))); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t2(content) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t2_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)));  </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t3(content) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t3_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)));    </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t4(content) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t4_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)));</span><br></pre></td></tr></table></figure><h3 id="1-1-1-id"><a href="#1-1-1-id" class="headerlink" title="1.1.1 id"></a>1.1.1 id</h3><p>select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序, 三种情况</p><ul><li>id相同，执行顺序由上至下 </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1,t2,t3,t4</span><br></pre></td></tr></table></figure><ul><li>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行 </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span></span><br><span class="line">t1.id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">t1 </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t1.id <span class="operator">=</span> ( <span class="keyword">SELECT</span> t2.id <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> t2.id <span class="operator">=</span> ( <span class="keyword">SELECT</span> t3.id <span class="keyword">FROM</span> t3 <span class="keyword">WHERE</span> t3.content <span class="operator">=</span> <span class="string">&#x27;t3_354&#x27;</span> ) )</span><br></pre></td></tr></table></figure><ul><li>id相同，不同，同时存在</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span></span><br><span class="line">t1.id,</span><br><span class="line">(<span class="keyword">select</span> t4.id <span class="keyword">from</span> t4 <span class="keyword">where</span> t4.id <span class="operator">=</span> t1.id)id4</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">t1,t2</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><strong>id如果相同，可以认为是一组，从上往下顺序执行</strong></li><li><strong>在所有组中，id值越大，优先级越高，越先执行</strong> </li><li><strong>id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</strong></li></ul><h3 id="1-1-2-select-type"><a href="#1-1-2-select-type" class="headerlink" title="1.1.2 select_type"></a>1.1.2 select_type</h3><p><strong>SIMPLE</strong> : 简单的 select 查询,查询中不包含子查询或者UNION</p><p><strong>PRIMARY</strong> :查询中若包含任何复杂的子部分，最外层查询则被标记为primary</p><p><strong>SUBQUERY</strong>: 在SELECT或WHERE列表中包含了子查询</p><p><strong>DEPENDENT SUBQUERY</strong>: 在SELECT或WHERE列表中包含了子查询,子查询基于外层</p><p><strong>UNCACHEABLE SUBQUREY</strong>: 表示这个subquery的查询要受到外部表查询的影响</p><p><strong>DERIVED</strong>: 在FROM列表中包含的子查询被标记为DERIVED(衍生) MySQL会递归执行这些子查询, 把结果放在临时表里</p><p><strong>UNION</strong>: 这是UNION语句其中的一个SQL元素 （union和union all : 联合数据，并且去重，字段名和数量相同;union all 不去重）</p><p><strong>UNION RESULT</strong>: 从UNION表获取结果的SELECT （去重操作返回的临时表）</p><h3 id="1-1-3-table"><a href="#1-1-3-table" class="headerlink" title="1.1.3 table"></a>1.1.3 table</h3><p>显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称</p><h3 id="1-1-4-partitions"><a href="#1-1-4-partitions" class="headerlink" title="1.1.4 partitions"></a>1.1.4 partitions</h3><p>代表分区表中的命中情况，非分区表，该项为null</p><h3 id="1-1-5-type-效率"><a href="#1-1-5-type-效率" class="headerlink" title="1.1.5 type(效率)"></a>1.1.5 <code>type</code>(效率)</h3><p>对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。</p><p>常用的类型有： <strong>ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）</strong></p><p><strong>ALL</strong>: Full Table Scan， MySQL将遍历全表以找到匹配的行（<code>全表扫描，扫描所有的子节点</code>）</p><p><strong>index</strong>: Full Index Scan，index与ALL区别为index类型只遍历索引树, all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的 （<code>扫描所有的非叶子节点，即索引</code>）</p><p><strong>range</strong>: 只检索给定范围的行，使用一个索引来选择行, <strong>范围索引扫描比全表扫描要好</strong>，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引 （<code>查询的基础级别，查询部分非叶子节点，即查询范围内的索引</code>）</p><p><strong>ref</strong>:  表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 （<code>命中部分索引</code>）</p><p><strong>eq_ref</strong>: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件（<code>完全命中索引</code>）</p><p><code>非常用级别以下</code></p><p><strong>const</strong>: 表示通过索引一次就找到了,const用于primary key或者unique索引, 因为只匹配一行数据，所以很快 如将主键置于where列表中，MySQL就能将该查询转换为一个常量</p><p><strong>system</strong>: 表仅有一行记录，这是const类型的特例，查询起来非常迅速</p><p><strong>NULL</strong>: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p><p><strong>index_merge</strong>:在查询过程中需要多个索引组合使用，通常出现在有 or 的关键字的sql中</p><p><strong>ref_or_null</strong>:  对于某个字段既需要关联条件，也需要null值得情况下。查询优化器会选择用ref_or_null连接查询。</p><p><strong>index_subquery</strong>:利用索引来关联子查询，不再全表扫描</p><p><strong>unique_subquery</strong> :该联接类型类似于index_subquery, 子查询中的唯一索引</p><p> <strong>备注：一般来说，得保证查询至少达到range级别，最好能达到ref。</strong> </p><h3 id="1-1-6-possible-keys"><a href="#1-1-6-possible-keys" class="headerlink" title="1.1.6 possible_keys"></a>1.1.6 possible_keys</h3><p>指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）</p><h3 id="1-1-7-key"><a href="#1-1-7-key" class="headerlink" title="1.1.7 key"></a>1.1.7 key</h3><p>key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中</p><h3 id="1-1-8-key-len"><a href="#1-1-8-key-len" class="headerlink" title="1.1.8 key_len"></a>1.1.8 key_len</h3><p>key_len表示索引使用的字节数，根据这个值可以判断索引的使用情况，特别是在组合索引的时候，判断该索引有多少部分被使用到非常重要, 值越小索引的效果越好。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> t3(content);</span><br></pre></td></tr></table></figure><p><strong>计算逻辑:</strong> </p><ul><li><p>先看索引上字段的类型+长度比如 int=4 ; varchar(20) =20 ; char(20) =20 </p></li><li><p>如果是varchar或者char这种字符串字段，视字符集要乘不同的值，比如utf-8要乘 3，GBK要乘2</p></li><li><p>varchar这种动态字符串要加2个字节</p></li><li><p>允许为空的字段要加1个字节 </p><p><strong>复合索引：多个列为索引（最左原则，最有原则)</strong></p><ul><li>最左原则：查询条件（where）必须依次索引设定来查询（服务器会进行SQL优化,尽量保持一直必变优化，浪费性能），依次匹配会进行部分命中和全部命中，当全部不命中时则索引失效。- <ul><li>int型字段，长度为4（因为int为4字节）</li><li>varchar类型字段：为设置的长度*编码集的字节数^（例如：utf-8：3字节，GTK:2字节）^ +是否为允许为null（是：1，否：0）+2^(varchar为动态字符)^     &gt; 例如varchar(20) = 20 * 3 + 1 + 2 = 73 </li></ul></li><li>最右原则：查询条件中包含一个字段进行 &gt; 和 &lt; 筛选时，这个字段索引应该放在最右面</li></ul></li></ul><h3 id="1-1-9-ref"><a href="#1-1-9-ref" class="headerlink" title="1.1.9 ref"></a>1.1.9 ref</h3><p>显示将哪些列或常量与键列中命名的索引进行比较，以从表中选择行</p><h3 id="1-1-10-rows"><a href="#1-1-10-rows" class="headerlink" title="1.1.10 rows"></a>1.1.10 rows</h3><p> 估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p><h3 id="1-1-11-filtered"><a href="#1-1-11-filtered" class="headerlink" title="1.1.11 filtered"></a>1.1.11 filtered</h3><p>这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，<strong>注意是百分比，不是具体记录数</strong></p><h3 id="1-1-12-Extra（附加数据）"><a href="#1-1-12-Extra（附加数据）" class="headerlink" title="1.1.12 Extra（附加数据）"></a>1.1.12 Extra（附加数据）</h3><p>该列包含MySQL解决查询的详细信息,有以下几种情况：</p><p>**Using where:**不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p><p><strong>Using temporary</strong>：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p><p><strong>Using filesort</strong>：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”（<code>出现文件排序是因为排序字段不是索引字段，尽量减少文件排序多使用索引字段进行排序，也可以使用java排序，java排序比文件排序效率高</code>）</p><p><strong>Using join buffer</strong>：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p><p><strong>Impossible where</strong>：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</p><p><strong>Select tables optimized away</strong>：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p><p><strong>No tables used</strong>：Query语句中使用from dual 或不含任何from子句</p><h2 id="1-2-注意事项"><a href="#1-2-注意事项" class="headerlink" title="1.2 注意事项"></a>1.2 注意事项</h2><ul><li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li><li>EXPLAIN不考虑各种Cache</li><li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li><li>部分统计信息是估算的，并非精确值</li><li>EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划</li></ul><h1 id="2-数据准备"><a href="#2-数据准备" class="headerlink" title="2 数据准备"></a>2 数据准备</h1><h2 id="2-1-建表"><a href="#2-1-建表" class="headerlink" title="2.1 建表"></a>2.1 建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept` (</span><br><span class="line"> `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `deptName` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `address` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `ceo` <span class="type">INT</span> <span class="keyword">NULL</span> ,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `emp` (</span><br><span class="line"> `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `empno` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line"> `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `deptId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line"> #<span class="keyword">CONSTRAINT</span> `fk_dept_id` <span class="keyword">FOREIGN</span> KEY (`deptId`) <span class="keyword">REFERENCES</span> `t_dept` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-2-设置参数"><a href="#2-2-设置参数" class="headerlink" title="2.2 设置参数"></a>2.2 设置参数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建函数，假如报错：This <span class="keyword">function</span> has <span class="keyword">none</span> <span class="keyword">of</span> DETERMINISTIC......</span><br><span class="line"># 由于开启过慢查询日志bin<span class="operator">-</span>log, 我们就必须为我们的<span class="keyword">function</span>指定一个参数。</span><br><span class="line">#主从复制，主机会将写操作记录在bin<span class="operator">-</span>log日志中。从机读取bin<span class="operator">-</span>log日志，执行语句来同步数据。</span><br><span class="line">#如果使用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql不开启创建函数设置</span><br><span class="line">#查看mysql是否允许创建函数：</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_bin_trust_function_creators&#x27;</span>;</span><br><span class="line">#命令开启：允许创建函数设置：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>; </span><br><span class="line"># 不加<span class="keyword">global</span>只是当前窗口有效。mysqld重启，上述参数又会消失。</span><br><span class="line">#永久方法：</span><br><span class="line">•windows下：my.ini[mysqld]加上：log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>  </span><br><span class="line">•linux下：<span class="operator">/</span>etc<span class="operator">/</span>my.cnf下my.cnf[mysqld]加上：log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="2-3-创建函数"><a href="#2-3-创建函数" class="headerlink" title="2.3 创建函数"></a>2.3 创建函数</h2><p>随机产生字符串</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line"><span class="keyword">BEGIN</span>    </span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">WHILE i <span class="operator">&lt;</span> n DO  </span><br><span class="line"><span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));  </span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"> </span><br><span class="line">#假如要删除</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> rand_string;</span><br></pre></td></tr></table></figure><p>随机产生部门编号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#用于随机产生多少到多少的编号</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span>  rand_num (from_num <span class="type">INT</span> ,to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span>   </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span> from_num<span class="operator">+</span><span class="number">1</span>))   ;</span><br><span class="line"><span class="keyword">RETURN</span> i;  </span><br><span class="line"><span class="keyword">END</span>$$ </span><br><span class="line"> </span><br><span class="line">#假如要删除</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> rand_num;</span><br></pre></td></tr></table></figure><h2 id="2-4-创建存储过程"><a href="#2-4-创建存储过程" class="headerlink" title="2.4 创建存储过程"></a>2.4 创建存储过程</h2><p>创建往emp表中插入数据的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span>  insert_emp(  <span class="keyword">START</span> <span class="type">INT</span> ,  max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;   </span><br><span class="line"> <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    #设置手动提交事务</span><br><span class="line"> REPEAT  #循环</span><br><span class="line"> <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;  #赋值</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (empno, NAME ,age ,deptid ) <span class="keyword">VALUES</span> ((<span class="keyword">START</span><span class="operator">+</span>i),rand_string(<span class="number">6</span>),rand_num(<span class="number">30</span>,<span class="number">50</span>),rand_num(<span class="number">1</span>,<span class="number">10000</span>));  </span><br><span class="line"> UNTIL i <span class="operator">=</span> max_num  </span><br><span class="line"> <span class="keyword">END</span> REPEAT;  </span><br><span class="line"> <span class="keyword">COMMIT</span>;  #提交事务</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line"> </span><br><span class="line">#删除</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PROCEDURE</span> insert_emp;</span><br></pre></td></tr></table></figure><p>创建往dept表中插入数据的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往dept表添加随机数据</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `insert_dept`(  max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;   </span><br><span class="line"> <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line"> REPEAT  </span><br><span class="line"> <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;  </span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept ( deptname,address,ceo ) <span class="keyword">VALUES</span> (rand_string(<span class="number">8</span>),rand_string(<span class="number">10</span>),rand_num(<span class="number">1</span>,<span class="number">500000</span>));  </span><br><span class="line"> UNTIL i <span class="operator">=</span> max_num  </span><br><span class="line"> <span class="keyword">END</span> REPEAT;  </span><br><span class="line"> <span class="keyword">COMMIT</span>; </span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line"> </span><br><span class="line">#删除</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PROCEDURE</span> insert_dept;</span><br></pre></td></tr></table></figure><p>删除表上所有索引的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">PROCEDURE</span> `proc_drop_index`(dbname <span class="type">VARCHAR</span>(<span class="number">200</span>),tablename <span class="type">VARCHAR</span>(<span class="number">200</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">       <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> ct <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> _index <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> _cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span>  <span class="keyword">SELECT</span>   index_name   <span class="keyword">FROM</span> information_schema.STATISTICS   <span class="keyword">WHERE</span> table_schema<span class="operator">=</span>dbname <span class="keyword">AND</span> table_name<span class="operator">=</span>tablename <span class="keyword">AND</span> seq_in_index<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span>    index_name <span class="operator">&lt;&gt;</span><span class="string">&#x27;PRIMARY&#x27;</span>  ;</span><br><span class="line">#每个游标必须使用不同的<span class="keyword">declare</span> continue handler <span class="keyword">for</span> <span class="keyword">not</span> found <span class="keyword">set</span> done<span class="operator">=</span><span class="number">1</span>来控制游标的结束</span><br><span class="line">       <span class="keyword">DECLARE</span>  CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">set</span> done<span class="operator">=</span><span class="number">2</span> ;      </span><br><span class="line">#若没有数据返回,程序继续,并将变量done设为<span class="number">2</span></span><br><span class="line">        <span class="keyword">OPEN</span> _cur;</span><br><span class="line">        <span class="keyword">FETCH</span> _cur <span class="keyword">INTO</span> _index;</span><br><span class="line">        WHILE  _index<span class="operator">&lt;&gt;</span><span class="string">&#x27;&#x27;</span> DO </span><br><span class="line">               <span class="keyword">SET</span> <span class="variable">@str</span> <span class="operator">=</span> CONCAT(&quot;drop index &quot; , _index , &quot; on &quot; , tablename ); </span><br><span class="line">               <span class="keyword">PREPARE</span> sql_str <span class="keyword">FROM</span> <span class="variable">@str</span> ;</span><br><span class="line">               <span class="keyword">EXECUTE</span>  sql_str;</span><br><span class="line">               <span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> sql_str;</span><br><span class="line">               <span class="keyword">SET</span> _index<span class="operator">=</span><span class="string">&#x27;&#x27;</span>; </span><br><span class="line">               <span class="keyword">FETCH</span> _cur <span class="keyword">INTO</span> _index; </span><br><span class="line">        <span class="keyword">END</span> WHILE;</span><br><span class="line">   <span class="keyword">CLOSE</span> _cur;</span><br><span class="line"><span class="keyword">END</span>$$</span><br></pre></td></tr></table></figure><h2 id="2-5-调用存储过程"><a href="#2-5-调用存储过程" class="headerlink" title="2.5 调用存储过程"></a>2.5 调用存储过程</h2><p>Dept</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往dept表添加<span class="number">1</span>万条数据  </span><br><span class="line"><span class="keyword">CALL</span> insert_dept(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p>Emp</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往emp表添加<span class="number">50</span>万条数据  </span><br><span class="line"><span class="keyword">CALL</span> insert_emp(<span class="number">100000</span>,<span class="number">500000</span>);</span><br></pre></td></tr></table></figure><h1 id="3-SQL优化"><a href="#3-SQL优化" class="headerlink" title="3 SQL优化"></a>3 SQL优化</h1><h2 id="3-1-索引失效"><a href="#3-1-索引失效" class="headerlink" title="3.1 索引失效"></a>3.1 索引失效</h2><h3 id="3-3-1-全值匹配"><a href="#3-3-1-全值匹配" class="headerlink" title="3.3.1 全值匹配"></a>3.3.1 全值匹配</h3><p>系统中经常出现的sql语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">and</span> deptid<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">and</span> deptid<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>思考: 索引应该如何建立 ？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> emp(age); #单值索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_deptid <span class="keyword">ON</span> emp(age,deptid);#复合索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_deptid_name <span class="keyword">ON</span> emp(age,deptid,NAME);#复合索引</span><br></pre></td></tr></table></figure><h3 id="3-3-2-最左法则"><a href="#3-3-2-最左法则" class="headerlink" title="3.3.2 最左法则"></a>3.3.2 最左法则</h3><p>如果系统经常出现的sql如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span> ;</span><br><span class="line">或者</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.deptid<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>; </span><br></pre></td></tr></table></figure><p> <strong>思考: 那原来的idx_age_deptid_name 还能否正常使用？</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptid<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>; </span><br></pre></td></tr></table></figure><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p><p>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#全值匹配</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">and</span> deptid<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">and</span> deptid<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#索引创建三种方案（<span class="number">1.</span>单值索引 <span class="number">2.</span>两列复合查询 <span class="number">3.</span>三列复合查询）</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> emp(age);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_deptid <span class="keyword">ON</span> emp(age,deptid);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_deptid_name <span class="keyword">ON</span> emp(age,deptid,NAME);</span><br><span class="line"></span><br><span class="line">#删除索引</span><br><span class="line"><span class="keyword">drop</span> index idx_age <span class="keyword">ON</span> emp;</span><br><span class="line"><span class="keyword">drop</span> index idx_age_deptid <span class="keyword">ON</span> emp;</span><br><span class="line"><span class="keyword">drop</span> index idx_age_deptid_name <span class="keyword">ON</span> emp;</span><br><span class="line"></span><br><span class="line">#索引命中规则为最左法则，部门命中或者全部命中，多个索引时命中百分比高的索引树优先采用，</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptid<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">#最左法则，第一个查询字段必须和索引的第一个字段相同，否则索引失效</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span><span class="keyword">and</span> deptid<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">#查询字段为复合索引字段所有字段时，<span class="keyword">sql</span>服务层会优化查询顺序为索引字段查询顺序（尽量避免顺序错乱）</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">and</span> deptid<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">#查询字段为复合索引字段的子集时，顺序相同时所有查询字段命中</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line">#查询字段为复合索引字段的子集时，顺序不相同时左边字段对应复合索引位置的字段才命中</span><br></pre></td></tr></table></figure><h3 id="3-3-3-计算、函数"><a href="#3-3-3-计算、函数" class="headerlink" title="3.3.3 计算、函数"></a>3.3.3 计算、函数</h3><p>模糊查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#创建索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> emp(NAME);</span><br><span class="line">#普通<span class="keyword">like</span>:可以触发索引<span class="operator">/</span>也可能会失效(后面会讲到,注意<span class="operator">%</span>为前缀匹配)</span><br><span class="line">#前缀查询，索引生效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line">#<span class="operator">%</span>放在中间查询，索引生效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%qw&#x27;</span>;</span><br><span class="line">#<span class="operator">%</span>放在最前面查询，索引完全失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">LIKE</span> <span class="string">&#x27;%qw&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#函数模糊查询: 索引完全失效 subString（截取查询，<span class="keyword">LEFT</span>(emp.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>，name的左边三个字母为abc）</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(emp.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>; </span><br><span class="line">#删除索引</span><br><span class="line"><span class="keyword">drop</span> INDEX idx_name <span class="keyword">ON</span> emp;</span><br></pre></td></tr></table></figure><h3 id="3-3-4-范围条件"><a href="#3-3-4-范围条件" class="headerlink" title="3.3.4 范围条件"></a>3.3.4 范围条件</h3><p>出现的sql如下：（查询条件中出现大于或者小于判断时,一般只有一个字段进行大小于判断）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#索引 idx_age_deptid_name这个索引还能正常使用么？不能，范围右边的列不能使用（部分命中）</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> emp.deptId<span class="operator">&gt;</span><span class="number">20</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> ; </span><br></pre></td></tr></table></figure><p>索引优化:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将范围查询条件放置语句最后</span><br><span class="line"><span class="keyword">create</span> index idx_age_name_deptid <span class="keyword">on</span> emp(age,name,deptid);</span><br></pre></td></tr></table></figure><p> <strong>注意: 应用开发中范围查询，例如： 金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。</strong> </p><h3 id="3-3-5-非-（否定条件查询，索引完全失效（-和-lt-gt-都表示非））"><a href="#3-3-5-非-（否定条件查询，索引完全失效（-和-lt-gt-都表示非））" class="headerlink" title="3.3.5 非 （否定条件查询，索引完全失效（!= 和 &lt;&gt;都表示非））"></a>3.3.5 非 （否定条件查询，索引完全失效（!= 和 &lt;&gt;都表示非））</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#为name字段创建索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> emp(NAME);</span><br><span class="line">#执行查看索引是否失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="operator">&lt;&gt;</span> <span class="string">&#x27;abc&#x27;</span> ;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="operator">!=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-6-is-not-null与is-null"><a href="#3-3-6-is-not-null与is-null" class="headerlink" title="3.3.6 is not null与is null"></a>3.3.6 is not null与is null</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">IS</span> <span class="keyword">NULL</span>:可以触发索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NULL</span>; </span><br><span class="line">#<span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>:无法触发索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-7-like"><a href="#3-3-7-like" class="headerlink" title="3.3.7 like"></a>3.3.7 like</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#下列哪个<span class="keyword">sql</span>语句可以用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;ab%&#x27;</span>; </span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%ab%&#x27;</span>; </span><br></pre></td></tr></table></figure><h3 id="3-3-8-类型转换"><a href="#3-3-8-类型转换" class="headerlink" title="3.3.8 类型转换"></a>3.3.8 类型转换</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#下列哪个<span class="keyword">sql</span>语句可以用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="number">123</span>; </span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;123&#x27;</span>; </span><br></pre></td></tr></table></figure><h3 id="3-3-9-小结"><a href="#3-3-9-小结" class="headerlink" title="3.3.9 小结"></a>3.3.9 小结</h3><p>假设index(a,b,c)</p><table><thead><tr><th>Where语句</th><th>索引是否被使用</th></tr></thead><tbody><tr><td>where a =  3</td><td>Y,使用到a</td></tr><tr><td>where a =  3 and b = 5</td><td>Y,使用到a，b</td></tr><tr><td>where a =  3 and b = 5 and c = 4</td><td>Y,使用到a,b,c</td></tr><tr><td>where b =  3 或者 where b = 3 and c =  4 或者 where c =  4</td><td>N</td></tr><tr><td>where a =  3 and c = 5</td><td>使用到a， 但是c不可以，b中间断了</td></tr><tr><td>where a =  3 and b &gt; 4 and c = 5</td><td>使用到a和b， c不能用在范围之后，b断了</td></tr><tr><td>where a is  null and b is not null</td><td>is null 支持索引  但是is not null 不支持,所以 a 可以使用索引,但是 b不可以使用</td></tr><tr><td>where a  &lt;&gt; 3</td><td>不能使用索引</td></tr><tr><td>where  abs(a) =3</td><td>不能使用 索引</td></tr><tr><td>where a =  3 and b like ‘kk%’ and c = 4</td><td>Y,使用到a,b,c</td></tr><tr><td>where a =  3 and b like ‘%kk’ and c = 4</td><td>Y,只用到a</td></tr><tr><td>where a =  3 and b like ‘%kk%’ and c = 4</td><td>Y,只用到a</td></tr><tr><td>where a =  3 and b like ‘k%kk%’ and c =  4</td><td>Y,使用到a,b,c</td></tr></tbody></table><p><strong>索引创建原则:</strong></p><ul><li>对于单键索引，尽量选择过滤性更好的索引（例如：手机号，邮件，身份证）</li><li>在选择组合索引的时候，过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>选择组合索引时，尽量包含where中更多字段的索引</li><li>组合索引出现范围查询时，尽量把这个字段放在索引次序的最后面</li><li>尽量避免造成索引失效的情况</li></ul><h2 id="3-2-关联查询优化"><a href="#3-2-关联查询优化" class="headerlink" title="3.2 关联查询优化"></a>3.2 关联查询优化</h2><h3 id="3-2-1-数据准备"><a href="#3-2-1-数据准备" class="headerlink" title="3.2.1 数据准备"></a>3.2.1 数据准备</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#分类</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `class` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`card` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br><span class="line">#图书</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `book` (</span><br><span class="line">`bookid` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`card` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`bookid`)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br></pre></td></tr></table></figure><h3 id="3-2-2-left-right-join"><a href="#3-2-2-left-right-join" class="headerlink" title="3.2.2 left/right join"></a>3.2.2 left/right join</h3><p>下面开始explain分析</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> class <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> class.card <span class="operator">=</span> book.card;</span><br></pre></td></tr></table></figure><p>结论：type 有All      </p><p>添加索引优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> INDEX Y (card); </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> class <span class="keyword">ADD</span> INDEX X (card); </span><br></pre></td></tr></table></figure><h3 id="3-2-3-inner-join"><a href="#3-2-3-inner-join" class="headerlink" title="3.2.3 inner join"></a>3.2.3 inner join</h3><p>换成inner join（MySQL自动选择驱动表）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN  <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span>  class <span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> class.card<span class="operator">=</span>book.card;</span><br></pre></td></tr></table></figure><p>添加索引优化  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> INDEX Y (card);         </span><br><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">TABLE</span> class <span class="keyword">ADD</span> INDEX X (card);</span><br></pre></td></tr></table></figure><p>dept表和emp表的关联查询优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#关联查询优化 </span><br><span class="line">#左连接查询（左表为驱动表，右表为被驱动表）</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE dept.<span class="operator">*</span>,emp.`name` <span class="keyword">FROM</span> dept <span class="keyword">left</span> <span class="keyword">join</span> emp <span class="keyword">on</span> emp.deptId <span class="operator">=</span> dept.id;</span><br><span class="line">#直接查询，发现type中有<span class="keyword">ALL</span>，查询效率低下</span><br><span class="line">#进行索引优化（驱动表尽量选择数据量少的表作为驱动表,把被驱动表查询字段作为索引）(左右连接优化方式相同)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> index emp_deptId(deptId);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> dept <span class="keyword">add</span> index dept_id(id);</span><br><span class="line"></span><br><span class="line">#<span class="keyword">inner</span> <span class="keyword">join</span>查询，看似没有被驱动表，<span class="keyword">sql</span>优化器会自动选择数据量小的表做驱动表</span><br><span class="line">#索引优化，两个表的字段都添加索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE dept.<span class="operator">*</span>,emp.`name` <span class="keyword">FROM</span> dept <span class="keyword">inner</span> <span class="keyword">join</span> emp <span class="keyword">on</span> emp.deptId <span class="operator">=</span> dept.id;</span><br><span class="line">#进行索引优化</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> index emp_deptId(deptId);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> dept <span class="keyword">add</span> index dept_id(id);</span><br></pre></td></tr></table></figure><h3 id="3-2-4-小结"><a href="#3-2-4-小结" class="headerlink" title="3.2.4 小结"></a>3.2.4 小结</h3><ul><li>保证被驱动表的join字段被索引</li><li>left join 时，选择小表作为驱动表，大表作为被驱动表</li><li>inner join 时，mysql会自动将小结果集的表选为驱动表。</li><li>子查询尽量不要放在被驱动表，衍生表建不了索引</li><li>能够直接多表关联的尽量直接关联，不用子查询</li></ul><h2 id="3-3-子查询优化"><a href="#3-3-子查询优化" class="headerlink" title="3.3 子查询优化"></a>3.3 子查询优化</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#不推荐</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp a <span class="keyword">WHERE</span> a.id <span class="keyword">NOT</span> <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> b.ceo <span class="keyword">FROM</span> t_dept b <span class="keyword">WHERE</span> b.ceo <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>);</span><br><span class="line">#推荐</span><br><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span> <span class="keyword">FROM</span> t_emp a </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_dept b </span><br><span class="line"><span class="keyword">ON</span> a.id <span class="operator">=</span> b.ceo </span><br><span class="line"><span class="keyword">WHERE</span> b.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><h2 id="3-4-排序优化"><a href="#3-4-排序优化" class="headerlink" title="3.4 排序优化"></a>3.4 排序优化</h2><h3 id="3-4-1-排序优化"><a href="#3-4-1-排序优化" class="headerlink" title="3.4.1 排序优化"></a>3.4.1 排序优化</h3><p><strong>order by时不限制索引失效</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#创建索引  </span><br><span class="line"><span class="keyword">CREATE</span>  INDEX idx_age_deptid_name <span class="keyword">ON</span> emp (age,deptid,NAME)</span><br><span class="line">#不限制,索引失效</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span>  <span class="keyword">BY</span> age,deptid;   </span><br><span class="line">#增加limit过滤条件，使用上索引了。（全局数据太大索引作用不大，分页只查询小数据索引不失效）</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span>  <span class="keyword">BY</span> age,deptid LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>order by时顺序错误,索引失效</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建索引age,deptid,NAME</span><br><span class="line"><span class="keyword">CREATE</span>  INDEX idx_age_deptid_name <span class="keyword">ON</span> emp (age,deptid,NAME)</span><br><span class="line">#创建索引age,deptid,empno</span><br><span class="line"><span class="keyword">CREATE</span>  INDEX idx_age_deptid_empno <span class="keyword">ON</span> emp (age,deptid,empno); </span><br><span class="line">#以下哪些索引失效?</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> deptid;  </span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> deptid,NAME;   </span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> deptid,empno;  </span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME,deptid;  </span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptid<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age;  </span><br></pre></td></tr></table></figure><p><strong>order by时规则不一致, 索引失效</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> deptid <span class="keyword">DESC</span>, NAME <span class="keyword">DESC</span> ;  </span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> deptid <span class="keyword">ASC</span>, NAME <span class="keyword">DESC</span> ;      </span><br></pre></td></tr></table></figure><h3 id="3-4-2-案例实战"><a href="#3-4-2-案例实战" class="headerlink" title="3.4.2 案例实战"></a>3.4.2 案例实战</h3><p>执行案例前先清除emp上的索引，只留主键</p><p><strong>场景:查询年龄为30岁的，且员工编号小于101000的用户，按用户名称排序</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age <span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> empno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME ; </span><br></pre></td></tr></table></figure><p>type 是 ALL，即最坏的情况。Extra 里还出现了 Using filesort,也是最坏的情况。</p><p>优化思路：</p><p><strong>方案一: 尽量让where的过滤条件和排序使用上索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_empno_name <span class="keyword">ON</span> emp (age,empno,NAME);</span><br></pre></td></tr></table></figure><p><strong>方案二: 为了去掉filesort我们可以把索引建成</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#删除旧索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_age_empno_name <span class="keyword">ON</span> emp</span><br><span class="line">#创建新索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> emp(age,NAME);</span><br></pre></td></tr></table></figure><p>empno 和name这个两个字段二选其一, 优化掉了 using filesort。</p><p><strong>方案三: 选择范围过滤，放弃排序上的索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#删除旧索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_age_name <span class="keyword">ON</span> emp;</span><br><span class="line">#创建新索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_empno <span class="keyword">ON</span> emp(age,empno);</span><br></pre></td></tr></table></figure><p> <strong>结论: filesort，而且type为range, 但是效率更高了,为什么?</strong> </p><p>原因：</p><ul><li>两个索引同时存在，mysql自动选择最优的方案：（对于这个例子，mysql选择idx_age_empno），但是，随着数据量的变化，选择的索引也会随之变化的</li><li>所有的排序都是在条件过滤之后才执行的，所以，如果条件过滤掉大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。 相对的 empno&lt;101000 这个条件，如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。</li></ul><p> <strong>小结(重点):</strong> </p><p><strong>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</strong></p><h3 id="3-4-3-双路排序和单路排序"><a href="#3-4-3-双路排序和单路排序" class="headerlink" title="3.4.3 双路排序和单路排序"></a>3.4.3 双路排序和单路排序</h3><p>排序的字段若如果不在索引列上，则filesort会有两种算法<strong>双路排序</strong>和<strong>单路排序</strong></p><p><strong>双路排序</strong></p><p>MySQL 4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和order by列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出, 从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。取一批数据，要对磁盘进行两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</p><p><strong>单路排序</strong></p><p>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</p><p><strong>单路排序存在的问题</strong></p><p>在sort_buffer中，单路比多路要多占用很多空间，因为单路是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排……从而多次I/O。单路本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。优化策略如下:</p><ul><li><p>增大sort_buffer_size参数的设置</p></li><li><p>增大max_length_for_sort_data参数的设置</p></li><li><p>减少select 后面的查询的字段。</p></li></ul><h3 id="3-4-4-Order-By效率优化"><a href="#3-4-4-Order-By效率优化" class="headerlink" title="3.4.4 Order By效率优化"></a>3.4.4 Order By效率优化</h3><ol><li><p>Order by时select * 是一个大忌</p><ul><li>当Query的字段大小总和小于max_length_for_sort_data 而且排序字段不是TEXT|BLOB 类型时，会用单路排序，否则用多路排序</li><li>两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size</li></ul></li><li><p>尝试提高 sort_buffer_size</p><ul><li>不管用哪种算法，提高这个参数都会提高效率，要根据系统的能力去提高，因为这个参数是针对每个进程（connection）的 1M-8M之间调整。 MySQL5.7，InnoDB存储引擎默认值是1048576字节，1MB。</li></ul></li><li><p>尝试提高 max_length_for_sort_data</p><ul><li>提高这个参数， 会增加用改进算法的概率。</li><li>但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。如果需要返回的列的总长度大于max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192字节之间调整</li></ul></li></ol><h3 id="3-4-5-GROUP-BY优化"><a href="#3-4-5-GROUP-BY优化" class="headerlink" title="3.4.5 GROUP BY优化"></a>3.4.5 GROUP BY优化</h3><p>group by 使用索引的原则几乎跟order by一致 ，唯一区别：</p><ul><li><p>group by 先排序再分组，遵照索引建的最佳左前缀法则</p></li><li><p>当无法使用索引列，增大max_length_for_sort_data和sort_buffer_size参数的设置</p></li><li><p>where高于having, 能写在where限定的条件就不要写在having中了</p></li></ul><h2 id="3-5-覆盖索引"><a href="#3-5-覆盖索引" class="headerlink" title="3.5 覆盖索引"></a>3.5 覆盖索引</h2><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。** 一个索引包含了满足查询结果的数据就叫做覆盖索引 **</p><p><strong>理解方式二</strong>：非聚集复合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段，也即，索引包含了查询正在查找的数据）。</p><h1 id="4-慢查询日志"><a href="#4-慢查询日志" class="headerlink" title="4 慢查询日志"></a>4 慢查询日志</h1><h2 id="4-1-慢查询日志介绍"><a href="#4-1-慢查询日志介绍" class="headerlink" title="4.1 慢查询日志介绍"></a>4.1 慢查询日志介绍</h2><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。 long_query_time的默认值为10，意思是运行10秒以上的语句。 由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。</p><p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。</p><p><strong>如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。</strong></p><h2 id="4-2-查看及开启"><a href="#4-2-查看及开启" class="headerlink" title="4.2 查看及开启"></a>4.2 查看及开启</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#默认情况下slow_query_log的值为OFF</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_query_log%&#x27;</span>;  </span><br></pre></td></tr></table></figure><p>命令行开启：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure><p>慢查询日志记录long_query_time时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;long_query_time&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time<span class="operator">=</span><span class="number">0.1</span>; </span><br></pre></td></tr></table></figure><p><strong>注意: 运行时间正好等于long_query_time的情况，并不会被记录下来。</strong></p><p>永久生效</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">修改my.cnf文件，[mysqld]下增加或修改参数slow_query_log</span> <span class="string">和slow_query_log_file后，然后重启MySQL服务器。也即将如下两行配置进my.cnf文件 </span></span><br><span class="line"><span class="attr">slow_query_log</span> =<span class="string">1</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=<span class="string">/var/lib/mysql/atguigu-slow.log </span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">log_output</span>=<span class="string">FILE</span></span><br></pre></td></tr></table></figure><p>查询当前系统中有多少条慢查询记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>; </span><br></pre></td></tr></table></figure><h2 id="4-3-mysqldumpslow"><a href="#4-3-mysqldumpslow" class="headerlink" title="4.3 mysqldumpslow"></a>4.3 mysqldumpslow</h2><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。 </p><p>-a: 不将数字抽象成N，字符串抽象成S</p><p>-s: 是表示按照何种方式排序；</p><p> c: 访问次数</p><p> l: 锁定时间</p><p> r: 返回记录</p><p> t: 查询时间</p><p> al:平均锁定时间</p><p> ar:平均返回记录数</p><p> at:平均查询时间</p><p>-t: 即为返回前面多少条的数据；</p><p>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#得到返回记录集最多的<span class="number">10</span>个<span class="keyword">SQL</span></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu<span class="operator">-</span>slow.log</span><br><span class="line">#得到访问次数最多的<span class="number">10</span>个<span class="keyword">SQL</span></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s c <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu<span class="operator">-</span>slow.log</span><br><span class="line">#得到按照时间排序的前<span class="number">10</span>条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">10</span> <span class="operator">-</span>g &quot;left join&quot; <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu<span class="operator">-</span>slow.log</span><br><span class="line">#另外建议在使用这些命令时结合 <span class="operator">|</span> 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu<span class="operator">-</span>slow.log <span class="operator">|</span> more</span><br></pre></td></tr></table></figure><h1 id="5-View视图"><a href="#5-View视图" class="headerlink" title="5 View视图"></a>5 View视图</h1><p>视图是将一段查询sql封装为一个虚拟的表。 这个虚拟表只保存了sql逻辑，不会保存任何查询结果。</p><p><strong>主要作用:</strong></p><ul><li>封装复杂sql语句，提高复用性</li><li>逻辑放在数据库上面，更新不需要发布程序，面对频繁的需求变更更灵活</li></ul><p><strong>常用场景:</strong></p><ul><li>共用查询结果</li><li>报表</li></ul><p><strong>语法:</strong></p><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> <span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name  <span class="keyword">WHERE</span> <span class="keyword">condition</span>  </span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查询</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> view_name </span><br><span class="line">#更新</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> view_name </span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL高级&quot;&gt;&lt;a href=&quot;#MySQL高级&quot; class=&quot;headerlink&quot; title=&quot;MySQL高级&quot;&gt;&lt;/a&gt;MySQL高级&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MySQL的索引（理论）&lt;/li&gt;
&lt;li&gt;如何让索引生效？（理论）—&amp;gt;这个索引生</summary>
      
    
    
    
    <category term="MySQL高级" scheme="http://example.com/categories/MySQL%E9%AB%98%E7%BA%A7/"/>
    
    
    <category term="Explain" scheme="http://example.com/tags/Explain/"/>
    
    <category term="SQL优化" scheme="http://example.com/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
    <category term="索引失效" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"/>
    
    <category term="慢查询日志" scheme="http://example.com/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/"/>
    
    <category term="View视图" scheme="http://example.com/tags/View%E8%A7%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://example.com/2022/12/02/MySQL/"/>
    <id>http://example.com/2022/12/02/MySQL/</id>
    <published>2022-12-02T15:39:17.000Z</published>
    <updated>2022-12-04T08:14:17.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ul><li><strong>mysql逻辑架构(理论)</strong></li><li><strong>索引(数据结构): mysql为什么要使用b+树</strong></li><li><strong>存储引擎: 5种</strong></li><li><strong>join查询</strong></li></ul><h1 id="1-逻辑架构"><a href="#1-逻辑架构" class="headerlink" title="1 逻辑架构"></a>1 逻辑架构</h1><h2 id="1-1-架构概览"><a href="#1-1-架构概览" class="headerlink" title="1.1 架构概览"></a>1.1 架构概览</h2><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。</p><p>这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 </p><p><img src="/2022/12/02/MySQL/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="逻辑架构图"></p><p>简单理解即为：</p><p><img src="/2022/12/02/MySQL/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png"></p><h3 id="1-1-1-连接层"><a href="#1-1-1-连接层" class="headerlink" title="1.1.1 连接层"></a>1.1.1 连接层</h3><p>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。</p><p>主要完成一些类似于连接处理、授权认证、及相关的安全方案。</p><p>在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。</p><p>同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 </p><h3 id="1-1-2-服务层"><a href="#1-1-2-服务层" class="headerlink" title="1.1.2 服务层"></a>1.1.2 服务层</h3><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。</p><p>所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p><p>在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。</p><p>如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><p>2.1 Management Serveices &amp; Utilities： 系统管理和控制工具 </p><p>2.2 SQL Interface: SQL接口</p><ul><li>接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</li></ul><p>2.3 Parser: 解析器</p><ul><li>SQL命令传递到解析器的时候会被解析器验证和解析。 </li></ul><p>2.4 Optimizer: 查询优化器。（索引命中）</p><ul><li>SQL语句在查询之前会使用查询优化器对查询进行优化。 </li><li>用一个例子就可以理解： select uid,name from user where gender= 1;</li><li>优化器来决定先投影还是先过滤。 </li></ul><p>2.5 Cache和Buffer： 查询缓存。</p><ul><li>如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 </li></ul><h3 id="1-1-3-引擎层"><a href="#1-1-3-引擎层" class="headerlink" title="1.1.3 引擎层"></a>1.1.3 引擎层</h3><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB </p><h3 id="1-1-4-存储层"><a href="#1-1-4-存储层" class="headerlink" title="1.1.4 存储层"></a>1.1.4 存储层</h3><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。 </p><h2 id="1-2-show-profiles"><a href="#1-2-show-profiles" class="headerlink" title="1.2 show profiles"></a>1.2 show profiles</h2><p>了解查询语句底层执行的过程：select @@profiling;查看是否开启计划。</p><ol><li>  修改配置文件/etc/my.cnf，先开启查询缓存</li></ol><p>新增一行：query_cache_type=1</p><p>重启mysql：systemctl restart mysqld</p><ol start="2"><li>  再开启查询执行计划</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%profiling%&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure><ol start="3"><li>  执行语句两次：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mydb.mytbl <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure><ol start="4"><li>  显示最近执行的语句</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profiles; </span><br></pre></td></tr></table></figure><p><img src="/2022/12/02/MySQL/image-20210602092918061.png" alt="image-20210602092918061"></p><ol start="5"><li>  显示执行计划</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile cpu,block io <span class="keyword">for</span> query <span class="number">6</span>; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/02/MySQL/image-20210602092929003.png" alt="image-20210602092929003"></p><p><img src="/2022/12/02/MySQL/image-20210602092950982.png" alt="image-20210602092950982"></p><p>执行编号7时，比执行编号6时少了很多信息，从下面截图中可以看出查询语句直接从缓存中获取数据；</p><p>==<strong>注意：SQL必须是一致的，否则，不能命中缓存。</strong>==</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#虽然查询结果一致，但并没有命中缓存。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mydb.mytbl <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mydb.mytbl <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">1</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="1-3-工作流程"><a href="#1-3-工作流程" class="headerlink" title="1.3 工作流程"></a>1.3 工作流程</h2><p>==<strong>mysql的查询流程：</strong>==</p><ol><li>首先，mysql客户端通过协议与mysql服务器建连接，发送查询语句，先检查查询缓存，如果命中，直接返回结果，否则进行语句解析，也就是说，在解析查询之前，服务器会先访问查询缓存(query cache)——它存储SELECT语句以及相应的查询结果集。</li><li>如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。</li><li>语法解析器和预处理：首先mysql通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”。</li><li>mysql解析器将使用mysql语法规则验证和解析查询；</li><li>预处理器则根据一些mysql规则进一步检查解析树是否合法。 </li><li>查询优化器当解析树被认为是合法的了，并且由优化器将其转化成执行计划。</li><li>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。 </li><li>mysql默认使用的BTREE索引，并且一个大致方向是：无论怎么折腾sql，至少在目前来说，mysql最多只用到表中的一个索引。</li></ol><h1 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2 存储引擎"></a>2 存储引擎</h1><h2 id="2-1-查看存储引擎"><a href="#2-1-查看存储引擎" class="headerlink" title="2.1 查看存储引擎"></a>2.1 查看存储引擎</h2><p>查看mysql提供什么存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/02/MySQL/image-20210602093145257.png" alt="image-20210602093145257"></p><p>查看默认的存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>; </span><br></pre></td></tr></table></figure><p><img src="/2022/12/02/MySQL/image-20210602093209298.png" alt="image-20210602093209298"></p><h2 id="2-2-引擎介绍"><a href="#2-2-引擎介绍" class="headerlink" title="2.2 引擎介绍"></a>2.2 引擎介绍</h2><h3 id="2-2-1-InnoDB"><a href="#2-2-1-InnoDB" class="headerlink" title="2.2.1 InnoDB"></a>2.2.1 InnoDB</h3><ul><li><strong>大于等于5.5之后，默认采用InnoDB引擎</strong>。</li><li>InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li><li>除了增加和查询外，还需要更新，删除操作，那么，应优选选择InnoDB存储引擎。</li><li>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</li></ul><h3 id="2-2-2-MyISAM"><a href="#2-2-2-MyISAM" class="headerlink" title="2.2.2 MyISAM"></a>2.2.2 MyISAM</h3><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务和行级锁，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</li><li>5.5之前默认的存储引擎</li><li>数据文件结构：<ul><li>.frm 存储定义表</li><li>.MYD 存储数据</li><li>.MYI 存储索引</li></ul></li></ul><p>==<strong>特别注意：</strong>==</p><ul><li>静态表字段都是非变长字段，存储占用空间比动态表多。存储数据时会按照列宽补足空格，但在访问时候并不会得到这些空格。</li><li>如果存储数据本身后面有空格，那么，查询时也会被去掉。</li><li>如果存储数据本身前面有空格，则查询时不会被去掉。</li><li>在没有where条件情况下统计表count(*)数量，不需要全表扫描，而是直接获取保存好的值。</li></ul><h3 id="2-2-3-Archive"><a href="#2-2-3-Archive" class="headerlink" title="2.2.3 Archive"></a>2.2.3 Archive</h3><ul><li>Archive档案存储引擎只支持<strong>INSERT</strong>和<strong>SELECT</strong>操作，在MySQL5.1之前不支持索引。</li><li>Archive表<strong>适合日志和数据采集（档案）</strong>类应用。</li><li>根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。</li></ul><h3 id="2-2-4-Blackhole"><a href="#2-2-4-Blackhole" class="headerlink" title="2.2.4 Blackhole"></a>2.2.4 Blackhole</h3><ul><li>Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。</li><li>但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。</li></ul><h3 id="2-2-5-CSV"><a href="#2-2-5-CSV" class="headerlink" title="2.2.5 CSV"></a>2.2.5 CSV</h3><ul><li>CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。</li><li>CSV引擎可以作为一种数据交换的机制，非常有用。</li><li>CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。</li></ul><h3 id="2-2-6-Memory引擎"><a href="#2-2-6-Memory引擎" class="headerlink" title="2.2.6 Memory引擎"></a>2.2.6 Memory引擎</h3><ul><li>如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。</li><li>Memory表至少比MyISAM表要快一个数量级。</li></ul><h3 id="2-2-7-Federated引擎"><a href="#2-2-7-Federated引擎" class="headerlink" title="2.2.7 Federated引擎"></a>2.2.7 Federated引擎</h3><ul><li>Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li></ul><h2 id="2-3-MyISAM和InnoDB"><a href="#2-3-MyISAM和InnoDB" class="headerlink" title="2.3 MyISAM和InnoDB"></a>2.3 MyISAM和InnoDB</h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr><tr><td>关注点</td><td>性能：节省资源、消耗少、简单业务</td><td>事务：并发写、事务、更大资源</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr></tbody></table><h1 id="3-索引入门"><a href="#3-索引入门" class="headerlink" title="3 索引入门"></a>3 索引入门</h1><h2 id="3-1-索引简介"><a href="#3-1-索引简介" class="headerlink" title="3.1 索引简介"></a>3.1 索引简介</h2><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL<strong>高效获取数据的数据结构</strong>。 </p><p>索引的本质：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”。</p><p>下图就是一种可能的索引方式示例：</p><p><img src="/2022/12/02/MySQL/image-20210602100619962.png" alt="image-20210602100619962">  </p><p><strong>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址</strong></p><p>为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</p><p>数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是<strong>索引</strong>。</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往<strong>以索引文件形式存储磁盘上</strong></p><h2 id="3-2-优点与缺点"><a href="#3-2-优点与缺点" class="headerlink" title="3.2 优点与缺点"></a>3.2 优点与缺点</h2><p>优点:</p><ul><li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li></ul><p>缺点:</p><ul><li><p>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以<strong>索引列也是要占用空间</strong>的</p></li><li><p>虽然索引大大提高了查询速度，同时却会<strong>降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。 因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</p></li></ul><h2 id="3-3-索引结构"><a href="#3-3-索引结构" class="headerlink" title="3.3 索引结构"></a>3.3 索引结构</h2><h3 id="3-3-1-Hash"><a href="#3-3-1-Hash" class="headerlink" title="3.3.1 Hash"></a>3.3.1 Hash</h3><p>加速查找速度的数据结构，常见的有两类：</p><p>(1)哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是O(1)；</p><p>哈希索引：</p><p><img src="/2022/12/02/MySQL/%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95-1670137812737.png"></p><p>(2)树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是O(log2N)；</p><p>可以看到，不管是读请求，还是写请求，哈希类型的索引，都要比树型的索引更快一些，</p><p><strong>那为什么，索引结构要设计成树型呢？</strong></p><p>想想<strong>范围/排序</strong>等其它SQL条件：</p><p>哈希型的索引，时间复杂度会退化为O(n)而<strong>树型的“有序”特性</strong>，依然能够保持O(log2N) 的高效率。</p><p>备注：InnoDB并不支持哈希索引。</p><h3 id="3-3-2-时间复杂度"><a href="#3-3-2-时间复杂度" class="headerlink" title="3.3.2 时间复杂度"></a>3.3.2 时间复杂度</h3><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。</p><p><img src="/2022/12/02/MySQL/image-20210602100853184.png" alt="image-20210602100853184"></p><p><img src="/2022/12/02/MySQL/image-20210602100858992.png" alt="image-20210602100858992"></p><h3 id="3-3-3-普通二叉树"><a href="#3-3-3-普通二叉树" class="headerlink" title="3.3.3 普通二叉树"></a>3.3.3 普通二叉树</h3><p>二叉树的特点：</p><ul><li>一个节点只能有两个子节点，也就是一个节点度不能超过2</li><li>左子节点 小于 本节点；右子节点大于等于 本节点，比我大的向右，比我小的向左</li></ul><p><img src="/2022/12/02/MySQL/image-20210602100943179.png" alt="image-20210602100943179"></p><p>对该二叉树的节点进行查找</p><ul><li><p>深度为1的节点的查找次数为1，</p></li><li><p>深度为2的节点的查找次数为2，</p></li><li><p>深度为N的节点的查找次数为N，</p></li></ul><p>结论：因此其平均查找次数为 (1+2+2+3+3+3) / 6 = 2.3次</p><blockquote><p>每次查找数据可以字节丢弃50%的数据进行查找，提高查找效率</p></blockquote><h3 id="3-3-4-平衡二叉树"><a href="#3-3-4-平衡二叉树" class="headerlink" title="3.3.4 平衡二叉树"></a>3.3.4 平衡二叉树</h3><p><strong>平衡二叉树</strong>（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：</p><p><strong>==它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。==</strong></p><p><code>这个方案很好的解决了二叉查找树退化成链表的问题</code>，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。</p><p><img src="/2022/12/02/MySQL/image-20210602101040214.png" alt="image-20210602101040214"></p><p>平衡二叉树大部分操作和二叉查找树类似，主要不同在于插入删除的时候平衡二叉树的平衡可能被改变，并且只有从那些插入点到根结点的路径上的结点的平衡性可能被改变，因为只有这些结点的子树可能变化。</p><h3 id="3-3-5-BTree-重点"><a href="#3-3-5-BTree-重点" class="headerlink" title="3.3.5 BTree(重点)"></a>3.3.5 BTree(重点)</h3><p><strong>B-Tree树即</strong>B树，B即Balanced，平衡的意思。</p><p><strong>B树的阶：</strong>节点的最多子节点个数。</p><p>B树的搜索，从根结点开始，对节点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点；重复，直到所对应的儿子指针为空，或已经是叶子节点, 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据, 搜索有可能在非叶子节点结束,其搜索性能等价于在关键字全集内做一次二分查找</p><p><img src="/2022/12/02/MySQL/image-20210602101333676.png" alt="image-20210602101333676"></p><p><strong>那么，我们思考一个问题，索引树会一次性加载吗？</strong></p><ul><li><code>数据库索引是存储在磁盘上的，如果数据很大，必然导致索引的大小也会很大，超过几个G</code>（好比新华字典字数多必然导致目录厚</li><li>当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：</li><li>逐一加载每一个<strong>磁盘页</strong>，因为磁盘页对应着索引树的节点。</li></ul><p> <img src="/2022/12/02/MySQL/image-20210602101455325.png" alt="image-20210602101455325"></p><p><strong>页</strong></p><p>Page是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在Page结构里。</p><p>Page分为几种类型：<strong>数据页（B-Tree Node），Undo页（Undo Log Page），系统页（System Page），事务数据页（Transaction System Page）</strong>等；**==每个数据页的大小为16kb==**，每个Page使用一个32位（一位表示的就是0或1）的int值来表示，正好对应Innodb最大64TB的存储容量(16kb * 2^32=64tib)</p><p><img src="/2022/12/02/MySQL/image-20210602101656506.png" alt="image-20210602101656506"></p><p><strong>块</strong></p><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB存储引擎中有页（Page）的概念，系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p><p>==<strong>Btree的查询流程</strong>==</p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。</p><p>模拟查找关键字29的过程：</p><ul><li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li><li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li><li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li><li>在磁盘块8中的关键字列表中找到关键字29。</li></ul><p>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个BTree查找效率的决定因素。</p><p><strong>BTree相对于AVLTree每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</strong></p><h3 id="3-3-6-B-Tree-重点"><a href="#3-3-6-B-Tree-重点" class="headerlink" title="3.3.6 B+Tree(重点)"></a>3.3.6 B+Tree(重点)</h3><p>  B+树是B树的变体，也是一种多路搜索树。B+树的搜索与B树也基本相同，区别是B+树只有达到叶子节点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</p><p>**==所有关键字都出现在叶子节点的链表中（即数据只能在叶子节点）==**，且链表中的关键字(数据)恰好是有序的。因此不可能在非叶子节点命中, <strong>==非叶子节点相当于是叶子节点的索引，叶子节点相当于是存储（关键字）数据的数据层==</strong></p><p><img src="/2022/12/02/MySQL/image-20210602102758064.png" alt="image-20210602102758064"></p><p>通常在 B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。 因此可以对 B+Tree 进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。 </p><p>InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用 4 个字节）或 BIGINT（占用 8 个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 16KB/(8B+8B)=1K 个键值（因为是估值，为方便计算，这里的 K 取值为 10^3。也就是说一个深度为 3 的 B+Tree 索引可以维护 10^3 _ 10^3 _ 10^3 = 10 亿条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2<del>4 层。MySQL 的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1</del>3 次磁盘 I/O 操作。</p><p>==<strong>BTree和B+Tree比较</strong>==</p><ul><li><strong>B</strong>树结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B树的深度较大，增大查询时的磁盘I/O次数进而影响查询效率。</li><li><strong>B+树</strong>中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+树的高度。</li></ul><h2 id="3-4-聚簇与非聚簇索引-重点"><a href="#3-4-聚簇与非聚簇索引-重点" class="headerlink" title="3.4 聚簇与非聚簇索引(重点)"></a>3.4 聚簇与非聚簇索引(重点)</h2><h3 id="3-4-1-聚簇索引"><a href="#3-4-1-聚簇索引" class="headerlink" title="3.4.1 聚簇索引"></a>3.4.1 聚簇索引</h3><p><strong>聚簇索引</strong>并不是一种单独的索引类型，而<strong>是一种数据存储方式</strong>。聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。</p><p>Innodb通过主键聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引。</p><p><strong>优点：</strong></p><ul><li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快</li></ul><p><strong>缺点：</strong></p><ul><li>插入速度严重依赖于插入顺序，按照主键的<strong>顺序插入</strong>是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列为主键</strong></li><li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</li></ul><h3 id="3-4-2-非聚簇索引"><a href="#3-4-2-非聚簇索引" class="headerlink" title="3.4.2 非聚簇索引"></a>3.4.2 非聚簇索引</h3><p>在<strong>聚簇索引之上创建的索引称之为非聚簇索引</strong>，非聚簇索引访问数据总是需要二次查找。非聚簇索引叶子节点存储的不再是行的物理位置，而是主键值。通过非聚簇索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。</p><p>Innodb非聚簇索引的叶子节点并<strong>不包含行记录的全部数据</strong>，叶子节点除了包含键值外，还包含了相应行数据的聚簇索引键。</p><p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。在innodb中有时也称非聚簇索引为二级索引或辅助索引。</p><h2 id="3-5-小结-笔记"><a href="#3-5-小结-笔记" class="headerlink" title="3.5 小结(笔记)"></a>3.5 小结(笔记)</h2><ul><li>数据库索引用于加速查询</li><li>虽然哈希索引是 O(1)，树索引是 O(log(n))，但 SQL 有很多“有序”需求，故数据库使用树型索引</li><li>InnoDB 不支持哈希索引</li><li>数据预读的思路是：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘 IO</li><li>数据库的索引最常用 B+树： <ul><li>很适合磁盘存储，能够充分利用局部性原理，磁盘预读； </li><li>很低的树高度，能够存储大量数据；</li><li>索引本身占用的内存很小；</li><li>能够很好的支持单点查询，范围查询，有序性查询；</li></ul></li></ul><h1 id="4-MySQL索引"><a href="#4-MySQL索引" class="headerlink" title="4 MySQL索引"></a>4 MySQL索引</h1><h2 id="4-1-单值索引"><a href="#4-1-单值索引" class="headerlink" title="4.1 单值索引"></a>4.1 单值索引</h2><p>即一个索引只包含单个列，一个表可以有多个单列索引，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">随表一起建索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">  KEY (customer_name)</span><br><span class="line">);</span><br><span class="line">单独建单值索引：</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_customer_name <span class="keyword">ON</span> customer(customer_name); </span><br><span class="line">删除索引：</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_customer_name  <span class="keyword">on</span> customer;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-2-唯一索引"><a href="#4-2-唯一索引" class="headerlink" title="4.2 唯一索引"></a>4.2 唯一索引</h2><p>索引列的值必须唯一，但允许有空值，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">随表一起建索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">  KEY (customer_name),</span><br><span class="line">  <span class="keyword">UNIQUE</span> (customer_no)</span><br><span class="line">);</span><br><span class="line">单独建唯一索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_customer_no <span class="keyword">ON</span> customer(customer_no); </span><br><span class="line">删除索引：</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_customer_no <span class="keyword">on</span> customer ;</span><br></pre></td></tr></table></figure><h2 id="4-3-主键索引"><a href="#4-3-主键索引" class="headerlink" title="4.3 主键索引"></a>4.3 主键索引</h2><p>设定为主键后数据库会自动建立索引（不能有null），<strong>innodb</strong>为聚簇索引，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">随表一起建索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer2 (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED   ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>) </span><br><span class="line">);</span><br><span class="line">单独建主键索引：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customer2 <span class="keyword">add</span> <span class="keyword">PRIMARY</span> KEY customer2(id);  </span><br><span class="line">删除主键索引：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customer2 <span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY ;  </span><br><span class="line">修改主键索引：</span><br><span class="line">必须先删除掉(<span class="keyword">drop</span>)原索引，再新建(<span class="keyword">add</span>)索引</span><br></pre></td></tr></table></figure><h2 id="4-4-复合索引"><a href="#4-4-复合索引" class="headerlink" title="4.4 复合索引"></a>4.4 复合索引</h2><p>即一个索引包含多个列，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 随表一起建索引：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">  KEY (customer_name),</span><br><span class="line">  <span class="keyword">UNIQUE</span> (customer_name),</span><br><span class="line">  KEY (customer_no,customer_name)</span><br><span class="line">);</span><br><span class="line">单独建索引：</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_customer_no_name <span class="keyword">ON</span> customer(customer_no,customer_name); </span><br><span class="line">删除索引：</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_customer_no_name  <span class="keyword">on</span> customer ;</span><br></pre></td></tr></table></figure><h2 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5 小结"></a>4.5 小结</h2><p>==<strong>哪些情况需要创建索引</strong>==</p><ul><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题，who？(在高并发下倾向创建组合索引)</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ul><p><strong>==哪些情况不要创建索引==</strong></p><ul><li><p>表记录太少，300万数据时MySQL性能就开始下降了，这时就可以开始开始优化了</p></li><li><p>经常增删改的表，提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件</p></li><li><p>where条件里用不到的字段</p></li><li><p>数据重复过滤性不好的字段</p></li></ul><h1 id="5-SQL优化-重点"><a href="#5-SQL优化-重点" class="headerlink" title="5 SQL优化(重点)"></a>5 SQL优化(重点)</h1><h2 id="5-1-SQL执行顺序"><a href="#5-1-SQL执行顺序" class="headerlink" title="5.1 SQL执行顺序"></a>5.1 SQL执行顺序</h2><p><img src="/2022/12/02/MySQL/image-20210602104459899.png" alt="image-20210602104459899"></p><p>从这个顺序中我们不难发现，所有的查询语句都是从from开始执行的，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。<br><strong>第一步：</strong>首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 <strong>vt1</strong>（选择相对小的表做基础表） </p><p><strong>第二步：</strong>接下来便是应用on筛选器，on中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 <strong>vt2</strong> </p><p><strong>第三步：</strong>如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 <strong>vt3</strong> </p><p><strong>第四步：</strong>如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3</p><p><strong>第五步：</strong>应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表<strong>vt4</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">注意</span>:<span class="string">对于包含outer join子句的查询，到底在on筛选器还是用where筛选器指定逻辑表达式呢？</span></span><br><span class="line"><span class="attr">on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer</span> <span class="string">join中还可以把移除的行再次添加回来，而where的移除的最终的。</span></span><br><span class="line"><span class="attr">举个简单的例子</span>:<span class="string"></span></span><br><span class="line"><span class="attr">有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。</span></span><br><span class="line"><span class="attr">为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名</span>=<span class="string">成绩.姓名）</span></span><br><span class="line"><span class="attr">那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了</span></span><br><span class="line"><span class="attr">但是我们用left</span> <span class="string">outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生</span></span><br><span class="line"><span class="attr">如果在on中应用学生.班级</span>=<span class="string">&#x27;x&#x27;的话，left outer join会把x班级的所有学生记录找回</span></span><br><span class="line"><span class="attr">所以只能在where筛选器中应用学生.班级</span>=<span class="string">&#x27;x&#x27; 因为它的过滤是最终的。 </span></span><br><span class="line"><span class="attr">总结</span>: <span class="string">最终过滤条件放在where语句中,on语句做数据匹配不要做筛选!!!</span></span><br></pre></td></tr></table></figure><p><strong>第六步：</strong>group by 子句将中的唯一的值组合成为一组，得到虚拟表<strong>vt5</strong>。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。==原因在于最终的结果集中只为每个组包含一行,这一点请牢记。== </p><p><strong>第七步：</strong>应用cube或者rollup选项，为vt5生成超组，生成<strong>vt6</strong></p><p>[^ROLLUP]: 是GROUP BY子句的一种扩展，可以为每个分组返回小计记录以及为所有分组返回总计记录。<br>[^CUBE]: 也是GROUP BY子句的一种扩展，可以返回每一个列组合的小计记录，同时在末尾加上总计记录。</p><p><strong>第八步：</strong>应用having筛选器，生成<strong>vt7</strong>。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器</p><p><strong>第九步：</strong>处理select子句。将vt7中的在select中出现的列筛选出来。生成<strong>vt8</strong></p><p><strong>第十步：</strong>应用distinct子句，vt8中移除相同的行，生成<strong>vt9</strong></p><p>[^注意]: ==如果应用了group by子句那么distinct是多余的，原因同样在于分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的==</p><p><strong>第十一步：</strong>应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表</p><p>[^游标]: sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。</p><p><strong>第十二步：</strong>返回结果给请求者即用户 </p><h2 id="5-2-测试数据"><a href="#5-2-测试数据" class="headerlink" title="5.2 测试数据"></a>5.2 测试数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_dept` (</span><br><span class="line"> `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `deptName` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `address` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_emp` (</span><br><span class="line"> `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `deptId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`empno` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"> KEY `idx_dept_id` (`deptId`)</span><br><span class="line"> #<span class="keyword">CONSTRAINT</span> `fk_dept_id` <span class="keyword">FOREIGN</span> KEY (`deptId`) <span class="keyword">REFERENCES</span> `t_dept` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;华山&#x27;</span>,<span class="string">&#x27;华山&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;丐帮&#x27;</span>,<span class="string">&#x27;洛阳&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;峨眉&#x27;</span>,<span class="string">&#x27;峨眉山&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">&#x27;武当&#x27;</span>,<span class="string">&#x27;武当山&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">&#x27;明教&#x27;</span>,<span class="string">&#x27;光明顶&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(id,deptName,address) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">&#x27;少林&#x27;</span>,<span class="string">&#x27;少林寺&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;风清扬&#x27;</span>,<span class="number">90</span>,<span class="number">1</span>,<span class="number">100001</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;岳不群&#x27;</span>,<span class="number">50</span>,<span class="number">1</span>,<span class="number">100002</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;令狐冲&#x27;</span>,<span class="number">24</span>,<span class="number">1</span>,<span class="number">100003</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">&#x27;洪七公&#x27;</span>,<span class="number">70</span>,<span class="number">2</span>,<span class="number">100004</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">&#x27;乔峰&#x27;</span>,<span class="number">35</span>,<span class="number">2</span>,<span class="number">100005</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">&#x27;灭绝师太&#x27;</span>,<span class="number">70</span>,<span class="number">3</span>,<span class="number">100006</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">7</span>,<span class="string">&#x27;周芷若&#x27;</span>,<span class="number">20</span>,<span class="number">3</span>,<span class="number">100007</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">8</span>,<span class="string">&#x27;张三丰&#x27;</span>,<span class="number">100</span>,<span class="number">4</span>,<span class="number">100008</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">9</span>,<span class="string">&#x27;张无忌&#x27;</span>,<span class="number">25</span>,<span class="number">5</span>,<span class="number">100009</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="number">10</span>,<span class="string">&#x27;韦小宝&#x27;</span>,<span class="number">18</span>,<span class="keyword">NULL</span>,<span class="number">100010</span>);</span><br></pre></td></tr></table></figure><h2 id="5-3-JOIN查询"><a href="#5-3-JOIN查询" class="headerlink" title="5.3 JOIN查询"></a>5.3 JOIN查询</h2><h3 id="5-3-1-join查询入门"><a href="#5-3-1-join查询入门" class="headerlink" title="5.3.1 join查询入门"></a>5.3.1 join查询入门</h3><p><strong>场景1: A、B两表共有(查询所有有部门的员工-&gt;员工和部门之间必须存在关联的数据)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">inner</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br></pre></td></tr></table></figure><p><strong>场景2:  A、B两表共有+A的独有（列出所有用户，并显示其机构信息）A的全集</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">left</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br></pre></td></tr></table></figure><p><strong>场景3: A、B两表共有+B的独有（列出所有部门，并显示其部门的员工信息 ）B的全集</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">right</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br></pre></td></tr></table></figure><p><strong>场景4: A的独有 （查询没有加入任何部门的员工）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">left</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">where</span> t_emp.deptId <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p><strong>场景5: B的独有（查询没有任何员工的部门）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">right</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">where</span> t_emp.empno <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p><strong>场景6:  AB全有（查询所有员工和所有部门）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">left</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">right</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br></pre></td></tr></table></figure><p><strong>场景7: A的独有+B的独有（查询没有加入任何部门的员工，以及查询出部门下没有任何员工的部门）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">left</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">where</span> t_emp.deptId <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> t_emp.<span class="operator">*</span>, t_dept.deptName,t_dept.address <span class="keyword">from</span> t_emp <span class="keyword">right</span> <span class="keyword">join</span> t_dept <span class="keyword">on</span> t_emp.deptId <span class="operator">=</span> t_dept.id</span><br><span class="line"><span class="keyword">where</span> t_emp.empno <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h3 id="5-3-2-join查询进阶"><a href="#5-3-2-join查询进阶" class="headerlink" title="5.3.2 join查询进阶"></a>5.3.2 join查询进阶</h3><p>增加掌门人字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_dept <span class="keyword">ADD</span> CEO <span class="type">INT</span>(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">4</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">6</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">8</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t_dept <span class="keyword">SET</span> CEO<span class="operator">=</span><span class="number">9</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><strong>场景8: 求各个门派对应的掌门人名称</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_dept.deptName, t_emp.name</span><br><span class="line"><span class="keyword">from</span> t_dept <span class="keyword">inner</span> <span class="keyword">join</span> t_emp <span class="keyword">on</span>  t_dept.CEO <span class="operator">=</span> t_emp.id</span><br></pre></td></tr></table></figure><p><strong>场景9: 求所有当上掌门人的平均年龄:</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">AVG</span>(t_emp.age)</span><br><span class="line"><span class="keyword">from</span> t_dept <span class="keyword">inner</span> <span class="keyword">join</span> t_emp <span class="keyword">on</span>  t_dept.CEO <span class="operator">=</span> t_emp.id</span><br></pre></td></tr></table></figure><p><strong>场景10: 求所有人物对应的掌门名称</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#临时表连接方式<span class="number">1</span><span class="comment">---部门和ceo关系</span></span><br><span class="line"><span class="keyword">SELECT</span> c.name,ab.ceoname <span class="keyword">FROM</span> t_emp c <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">( <span class="keyword">SELECT</span> b.id <span class="keyword">AS</span> deptId,a.name <span class="keyword">AS</span> ceoname <span class="keyword">FROM</span> t_emp a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_dept b <span class="keyword">ON</span> a.id <span class="operator">=</span> b.ceo ) ab</span><br><span class="line"><span class="keyword">ON</span> c.deptId <span class="operator">=</span> ab.deptId ;</span><br><span class="line"></span><br><span class="line">#临时表连接方式<span class="number">2</span><span class="comment">---人和CEO关系</span></span><br><span class="line"><span class="keyword">SELECT</span> ab.name,c.name <span class="keyword">AS</span> ceoname <span class="keyword">FROM</span> </span><br><span class="line">( <span class="keyword">SELECT</span> a.name,b.ceo <span class="keyword">FROM</span> t_emp a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_dept b <span class="keyword">ON</span> a.deptid <span class="operator">=</span> b.id ) ab</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_emp c <span class="keyword">ON</span> ab.ceo <span class="operator">=</span> c.id ;</span><br><span class="line"></span><br><span class="line">#三表左连接方式</span><br><span class="line"><span class="keyword">SELECT</span> a.name,c.name <span class="keyword">AS</span> ceoname <span class="keyword">FROM</span> t_emp a </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_dept b <span class="keyword">ON</span> a.deptid <span class="operator">=</span> b.id </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_emp c <span class="keyword">ON</span> b.ceo <span class="operator">=</span> c.id ;</span><br><span class="line"></span><br><span class="line">#子查询方式</span><br><span class="line"><span class="keyword">SELECT</span> a.name ,(<span class="keyword">SELECT</span> c.name <span class="keyword">FROM</span> t_emp c <span class="keyword">WHERE</span> c.id<span class="operator">=</span>b.ceo) <span class="keyword">AS</span> ceoname</span><br><span class="line"><span class="keyword">FROM</span> t_emp a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_dept b </span><br><span class="line"><span class="keyword">ON</span> a.deptid <span class="operator">=</span> b.id ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mysql逻辑架构(理论)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;索引(数</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="SQL优化" scheme="http://example.com/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="逻辑架构" scheme="http://example.com/tags/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"/>
    
    <category term="存储引擎" scheme="http://example.com/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    <category term="索引" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/11/23/hello-world/"/>
    <id>http://example.com/2022/11/23/hello-world/</id>
    <published>2022-11-23T06:26:25.992Z</published>
    <updated>2022-11-26T06:29:02.448Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="hello" scheme="http://example.com/categories/hello/"/>
    
    
    <category term="jQuery" scheme="http://example.com/tags/jQuery/"/>
    
    <category term="表格" scheme="http://example.com/tags/%E8%A1%A8%E6%A0%BC/"/>
    
    <category term="表单验证" scheme="http://example.com/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
</feed>
